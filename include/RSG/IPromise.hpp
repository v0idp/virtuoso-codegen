// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/byref.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: System
namespace System {
  // Forward declaring type: Action
  class Action;
  // Forward declaring type: Action`1<T>
  template<typename T>
  class Action_1;
  // Forward declaring type: Exception
  class Exception;
  // Forward declaring type: Func`1<TResult>
  template<typename TResult>
  class Func_1;
  // Forward declaring type: Func`2<T, TResult>
  template<typename T, typename TResult>
  class Func_2;
}
// Forward declaring namespace: RSG
namespace RSG {
  // Forward declaring type: IPromise`1<PromisedT>
  template<typename PromisedT>
  class IPromise_1;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: IEnumerable`1<T>
  template<typename T>
  class IEnumerable_1;
}
// Completed forward declares
// Type namespace: RSG
namespace RSG {
  // Forward declaring type: IPromise
  class IPromise;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::RSG::IPromise);
DEFINE_IL2CPP_ARG_TYPE(::RSG::IPromise*, "RSG", "IPromise");
// Type namespace: RSG
namespace RSG {
  // Size: 0x10
  #pragma pack(push, 1)
  // Autogenerated type: RSG.IPromise
  // [TokenAttribute] Offset: FFFFFFFF
  class IPromise {
    public:
    // public System.Int32 get_Id()
    // Offset: 0xFFFFFFFFFFFFFFFF
    int get_Id();
    // public RSG.IPromise WithName(System.String name)
    // Offset: 0xFFFFFFFFFFFFFFFF
    ::RSG::IPromise* WithName(::StringW name);
    // public System.Void Done(System.Action onResolved, System.Action`1<System.Exception> onRejected)
    // Offset: 0xFFFFFFFFFFFFFFFF
    void Done(::System::Action* onResolved, ::System::Action_1<::System::Exception*>* onRejected);
    // public System.Void Done(System.Action onResolved)
    // Offset: 0xFFFFFFFFFFFFFFFF
    void Done(::System::Action* onResolved);
    // public System.Void Done()
    // Offset: 0xFFFFFFFFFFFFFFFF
    void Done();
    // public RSG.IPromise Catch(System.Action`1<System.Exception> onRejected)
    // Offset: 0xFFFFFFFFFFFFFFFF
    ::RSG::IPromise* Catch(::System::Action_1<::System::Exception*>* onRejected);
    // public RSG.IPromise`1<ConvertedT> Then(System.Func`1<RSG.IPromise`1<ConvertedT>> onResolved)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class ConvertedT>
    ::RSG::IPromise_1<ConvertedT>* Then(::System::Func_1<::RSG::IPromise_1<ConvertedT>*>* onResolved) {
      static auto ___internal__logger = ::Logger::get().WithContext("::RSG::IPromise::Then");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(this, classof(::RSG::IPromise*), -1));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<ConvertedT>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<::RSG::IPromise_1<ConvertedT>*, false>(this, ___generic__method, onResolved);
    }
    // public RSG.IPromise Then(System.Func`1<RSG.IPromise> onResolved)
    // Offset: 0xFFFFFFFFFFFFFFFF
    ::RSG::IPromise* Then(::System::Func_1<::RSG::IPromise*>* onResolved);
    // public RSG.IPromise Then(System.Action onResolved)
    // Offset: 0xFFFFFFFFFFFFFFFF
    ::RSG::IPromise* Then(::System::Action* onResolved);
    // public RSG.IPromise`1<ConvertedT> Then(System.Func`1<RSG.IPromise`1<ConvertedT>> onResolved, System.Func`2<System.Exception,RSG.IPromise`1<ConvertedT>> onRejected)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class ConvertedT>
    ::RSG::IPromise_1<ConvertedT>* Then(::System::Func_1<::RSG::IPromise_1<ConvertedT>*>* onResolved, ::System::Func_2<::System::Exception*, ::RSG::IPromise_1<ConvertedT>*>* onRejected) {
      static auto ___internal__logger = ::Logger::get().WithContext("::RSG::IPromise::Then");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(this, classof(::RSG::IPromise*), -1));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<ConvertedT>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<::RSG::IPromise_1<ConvertedT>*, false>(this, ___generic__method, onResolved, onRejected);
    }
    // public RSG.IPromise Then(System.Func`1<RSG.IPromise> onResolved, System.Action`1<System.Exception> onRejected)
    // Offset: 0xFFFFFFFFFFFFFFFF
    ::RSG::IPromise* Then(::System::Func_1<::RSG::IPromise*>* onResolved, ::System::Action_1<::System::Exception*>* onRejected);
    // public RSG.IPromise Then(System.Action onResolved, System.Action`1<System.Exception> onRejected)
    // Offset: 0xFFFFFFFFFFFFFFFF
    ::RSG::IPromise* Then(::System::Action* onResolved, ::System::Action_1<::System::Exception*>* onRejected);
    // public RSG.IPromise`1<ConvertedT> Then(System.Func`1<RSG.IPromise`1<ConvertedT>> onResolved, System.Func`2<System.Exception,RSG.IPromise`1<ConvertedT>> onRejected, System.Action`1<System.Single> onProgress)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class ConvertedT>
    ::RSG::IPromise_1<ConvertedT>* Then(::System::Func_1<::RSG::IPromise_1<ConvertedT>*>* onResolved, ::System::Func_2<::System::Exception*, ::RSG::IPromise_1<ConvertedT>*>* onRejected, ::System::Action_1<float>* onProgress) {
      static auto ___internal__logger = ::Logger::get().WithContext("::RSG::IPromise::Then");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(this, classof(::RSG::IPromise*), -1));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<ConvertedT>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<::RSG::IPromise_1<ConvertedT>*, false>(this, ___generic__method, onResolved, onRejected, onProgress);
    }
    // public RSG.IPromise Then(System.Func`1<RSG.IPromise> onResolved, System.Action`1<System.Exception> onRejected, System.Action`1<System.Single> onProgress)
    // Offset: 0xFFFFFFFFFFFFFFFF
    ::RSG::IPromise* Then(::System::Func_1<::RSG::IPromise*>* onResolved, ::System::Action_1<::System::Exception*>* onRejected, ::System::Action_1<float>* onProgress);
    // public RSG.IPromise Then(System.Action onResolved, System.Action`1<System.Exception> onRejected, System.Action`1<System.Single> onProgress)
    // Offset: 0xFFFFFFFFFFFFFFFF
    ::RSG::IPromise* Then(::System::Action* onResolved, ::System::Action_1<::System::Exception*>* onRejected, ::System::Action_1<float>* onProgress);
    // public RSG.IPromise ThenAll(System.Func`1<System.Collections.Generic.IEnumerable`1<RSG.IPromise>> chain)
    // Offset: 0xFFFFFFFFFFFFFFFF
    ::RSG::IPromise* ThenAll(::System::Func_1<::System::Collections::Generic::IEnumerable_1<::RSG::IPromise*>*>* chain);
    // public RSG.IPromise`1<System.Collections.Generic.IEnumerable`1<ConvertedT>> ThenAll(System.Func`1<System.Collections.Generic.IEnumerable`1<RSG.IPromise`1<ConvertedT>>> chain)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class ConvertedT>
    ::RSG::IPromise_1<::System::Collections::Generic::IEnumerable_1<ConvertedT>*>* ThenAll(::System::Func_1<::System::Collections::Generic::IEnumerable_1<::RSG::IPromise_1<ConvertedT>*>*>* chain) {
      static auto ___internal__logger = ::Logger::get().WithContext("::RSG::IPromise::ThenAll");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(this, classof(::RSG::IPromise*), -1));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<ConvertedT>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<::RSG::IPromise_1<::System::Collections::Generic::IEnumerable_1<ConvertedT>*>*, false>(this, ___generic__method, chain);
    }
    // public RSG.IPromise ThenSequence(System.Func`1<System.Collections.Generic.IEnumerable`1<System.Func`1<RSG.IPromise>>> chain)
    // Offset: 0xFFFFFFFFFFFFFFFF
    ::RSG::IPromise* ThenSequence(::System::Func_1<::System::Collections::Generic::IEnumerable_1<::System::Func_1<::RSG::IPromise*>*>*>* chain);
    // public RSG.IPromise ThenRace(System.Func`1<System.Collections.Generic.IEnumerable`1<RSG.IPromise>> chain)
    // Offset: 0xFFFFFFFFFFFFFFFF
    ::RSG::IPromise* ThenRace(::System::Func_1<::System::Collections::Generic::IEnumerable_1<::RSG::IPromise*>*>* chain);
    // public RSG.IPromise`1<ConvertedT> ThenRace(System.Func`1<System.Collections.Generic.IEnumerable`1<RSG.IPromise`1<ConvertedT>>> chain)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class ConvertedT>
    ::RSG::IPromise_1<ConvertedT>* ThenRace(::System::Func_1<::System::Collections::Generic::IEnumerable_1<::RSG::IPromise_1<ConvertedT>*>*>* chain) {
      static auto ___internal__logger = ::Logger::get().WithContext("::RSG::IPromise::ThenRace");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(this, classof(::RSG::IPromise*), -1));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<ConvertedT>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<::RSG::IPromise_1<ConvertedT>*, false>(this, ___generic__method, chain);
    }
    // public RSG.IPromise Finally(System.Action onComplete)
    // Offset: 0xFFFFFFFFFFFFFFFF
    ::RSG::IPromise* Finally(::System::Action* onComplete);
    // public RSG.IPromise ContinueWith(System.Func`1<RSG.IPromise> onResolved)
    // Offset: 0xFFFFFFFFFFFFFFFF
    ::RSG::IPromise* ContinueWith(::System::Func_1<::RSG::IPromise*>* onResolved);
    // public RSG.IPromise`1<ConvertedT> ContinueWith(System.Func`1<RSG.IPromise`1<ConvertedT>> onComplete)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class ConvertedT>
    ::RSG::IPromise_1<ConvertedT>* ContinueWith(::System::Func_1<::RSG::IPromise_1<ConvertedT>*>* onComplete) {
      static auto ___internal__logger = ::Logger::get().WithContext("::RSG::IPromise::ContinueWith");
      auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::ResolveVtableSlot(this, classof(::RSG::IPromise*), -1));
      auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<ConvertedT>::get()}));
      return ::il2cpp_utils::RunMethodRethrow<::RSG::IPromise_1<ConvertedT>*, false>(this, ___generic__method, onComplete);
    }
    // public RSG.IPromise Progress(System.Action`1<System.Single> onProgress)
    // Offset: 0xFFFFFFFFFFFFFFFF
    ::RSG::IPromise* Progress(::System::Action_1<float>* onProgress);
  }; // RSG.IPromise
  #pragma pack(pop)
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: RSG::IPromise::get_Id
// Il2CppName: get_Id
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<int (RSG::IPromise::*)()>(&RSG::IPromise::get_Id)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(RSG::IPromise*), "get_Id", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: RSG::IPromise::WithName
// Il2CppName: WithName
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::RSG::IPromise* (RSG::IPromise::*)(::StringW)>(&RSG::IPromise::WithName)> {
  static const MethodInfo* get() {
    static auto* name = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(RSG::IPromise*), "WithName", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{name});
  }
};
// Writing MetadataGetter for method: RSG::IPromise::Done
// Il2CppName: Done
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (RSG::IPromise::*)(::System::Action*, ::System::Action_1<::System::Exception*>*)>(&RSG::IPromise::Done)> {
  static const MethodInfo* get() {
    static auto* onResolved = &::il2cpp_utils::GetClassFromName("System", "Action")->byval_arg;
    static auto* onRejected = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System", "Action`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Exception")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(RSG::IPromise*), "Done", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{onResolved, onRejected});
  }
};
// Writing MetadataGetter for method: RSG::IPromise::Done
// Il2CppName: Done
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (RSG::IPromise::*)(::System::Action*)>(&RSG::IPromise::Done)> {
  static const MethodInfo* get() {
    static auto* onResolved = &::il2cpp_utils::GetClassFromName("System", "Action")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(RSG::IPromise*), "Done", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{onResolved});
  }
};
// Writing MetadataGetter for method: RSG::IPromise::Done
// Il2CppName: Done
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (RSG::IPromise::*)()>(&RSG::IPromise::Done)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(RSG::IPromise*), "Done", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: RSG::IPromise::Catch
// Il2CppName: Catch
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::RSG::IPromise* (RSG::IPromise::*)(::System::Action_1<::System::Exception*>*)>(&RSG::IPromise::Catch)> {
  static const MethodInfo* get() {
    static auto* onRejected = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System", "Action`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Exception")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(RSG::IPromise*), "Catch", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{onRejected});
  }
};
// Writing MetadataGetter for method: RSG::IPromise::Then
// Il2CppName: Then
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: RSG::IPromise::Then
// Il2CppName: Then
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::RSG::IPromise* (RSG::IPromise::*)(::System::Func_1<::RSG::IPromise*>*)>(&RSG::IPromise::Then)> {
  static const MethodInfo* get() {
    static auto* onResolved = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System", "Func`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("RSG", "IPromise")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(RSG::IPromise*), "Then", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{onResolved});
  }
};
// Writing MetadataGetter for method: RSG::IPromise::Then
// Il2CppName: Then
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::RSG::IPromise* (RSG::IPromise::*)(::System::Action*)>(&RSG::IPromise::Then)> {
  static const MethodInfo* get() {
    static auto* onResolved = &::il2cpp_utils::GetClassFromName("System", "Action")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(RSG::IPromise*), "Then", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{onResolved});
  }
};
// Writing MetadataGetter for method: RSG::IPromise::Then
// Il2CppName: Then
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: RSG::IPromise::Then
// Il2CppName: Then
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::RSG::IPromise* (RSG::IPromise::*)(::System::Func_1<::RSG::IPromise*>*, ::System::Action_1<::System::Exception*>*)>(&RSG::IPromise::Then)> {
  static const MethodInfo* get() {
    static auto* onResolved = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System", "Func`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("RSG", "IPromise")})->byval_arg;
    static auto* onRejected = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System", "Action`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Exception")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(RSG::IPromise*), "Then", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{onResolved, onRejected});
  }
};
// Writing MetadataGetter for method: RSG::IPromise::Then
// Il2CppName: Then
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::RSG::IPromise* (RSG::IPromise::*)(::System::Action*, ::System::Action_1<::System::Exception*>*)>(&RSG::IPromise::Then)> {
  static const MethodInfo* get() {
    static auto* onResolved = &::il2cpp_utils::GetClassFromName("System", "Action")->byval_arg;
    static auto* onRejected = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System", "Action`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Exception")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(RSG::IPromise*), "Then", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{onResolved, onRejected});
  }
};
// Writing MetadataGetter for method: RSG::IPromise::Then
// Il2CppName: Then
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: RSG::IPromise::Then
// Il2CppName: Then
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::RSG::IPromise* (RSG::IPromise::*)(::System::Func_1<::RSG::IPromise*>*, ::System::Action_1<::System::Exception*>*, ::System::Action_1<float>*)>(&RSG::IPromise::Then)> {
  static const MethodInfo* get() {
    static auto* onResolved = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System", "Func`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("RSG", "IPromise")})->byval_arg;
    static auto* onRejected = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System", "Action`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Exception")})->byval_arg;
    static auto* onProgress = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System", "Action`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Single")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(RSG::IPromise*), "Then", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{onResolved, onRejected, onProgress});
  }
};
// Writing MetadataGetter for method: RSG::IPromise::Then
// Il2CppName: Then
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::RSG::IPromise* (RSG::IPromise::*)(::System::Action*, ::System::Action_1<::System::Exception*>*, ::System::Action_1<float>*)>(&RSG::IPromise::Then)> {
  static const MethodInfo* get() {
    static auto* onResolved = &::il2cpp_utils::GetClassFromName("System", "Action")->byval_arg;
    static auto* onRejected = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System", "Action`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Exception")})->byval_arg;
    static auto* onProgress = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System", "Action`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Single")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(RSG::IPromise*), "Then", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{onResolved, onRejected, onProgress});
  }
};
// Writing MetadataGetter for method: RSG::IPromise::ThenAll
// Il2CppName: ThenAll
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::RSG::IPromise* (RSG::IPromise::*)(::System::Func_1<::System::Collections::Generic::IEnumerable_1<::RSG::IPromise*>*>*)>(&RSG::IPromise::ThenAll)> {
  static const MethodInfo* get() {
    static auto* chain = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System", "Func`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "IEnumerable`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("RSG", "IPromise")})})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(RSG::IPromise*), "ThenAll", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{chain});
  }
};
// Writing MetadataGetter for method: RSG::IPromise::ThenAll
// Il2CppName: ThenAll
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: RSG::IPromise::ThenSequence
// Il2CppName: ThenSequence
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::RSG::IPromise* (RSG::IPromise::*)(::System::Func_1<::System::Collections::Generic::IEnumerable_1<::System::Func_1<::RSG::IPromise*>*>*>*)>(&RSG::IPromise::ThenSequence)> {
  static const MethodInfo* get() {
    static auto* chain = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System", "Func`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "IEnumerable`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System", "Func`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("RSG", "IPromise")})})})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(RSG::IPromise*), "ThenSequence", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{chain});
  }
};
// Writing MetadataGetter for method: RSG::IPromise::ThenRace
// Il2CppName: ThenRace
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::RSG::IPromise* (RSG::IPromise::*)(::System::Func_1<::System::Collections::Generic::IEnumerable_1<::RSG::IPromise*>*>*)>(&RSG::IPromise::ThenRace)> {
  static const MethodInfo* get() {
    static auto* chain = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System", "Func`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.Generic", "IEnumerable`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("RSG", "IPromise")})})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(RSG::IPromise*), "ThenRace", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{chain});
  }
};
// Writing MetadataGetter for method: RSG::IPromise::ThenRace
// Il2CppName: ThenRace
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: RSG::IPromise::Finally
// Il2CppName: Finally
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::RSG::IPromise* (RSG::IPromise::*)(::System::Action*)>(&RSG::IPromise::Finally)> {
  static const MethodInfo* get() {
    static auto* onComplete = &::il2cpp_utils::GetClassFromName("System", "Action")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(RSG::IPromise*), "Finally", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{onComplete});
  }
};
// Writing MetadataGetter for method: RSG::IPromise::ContinueWith
// Il2CppName: ContinueWith
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::RSG::IPromise* (RSG::IPromise::*)(::System::Func_1<::RSG::IPromise*>*)>(&RSG::IPromise::ContinueWith)> {
  static const MethodInfo* get() {
    static auto* onResolved = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System", "Func`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("RSG", "IPromise")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(RSG::IPromise*), "ContinueWith", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{onResolved});
  }
};
// Writing MetadataGetter for method: RSG::IPromise::ContinueWith
// Il2CppName: ContinueWith
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: RSG::IPromise::Progress
// Il2CppName: Progress
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::RSG::IPromise* (RSG::IPromise::*)(::System::Action_1<float>*)>(&RSG::IPromise::Progress)> {
  static const MethodInfo* get() {
    static auto* onProgress = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System", "Action`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System", "Single")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(RSG::IPromise*), "Progress", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{onProgress});
  }
};
