// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: UnityEngine.MonoBehaviour
#include "UnityEngine/MonoBehaviour.hpp"
// Including type: OVROverlay/OverlayType
#include "GlobalNamespace/OVROverlay.hpp"
// Including type: UnityEngine.Vector4
#include "UnityEngine/Vector4.hpp"
// Including type: UnityEngine.Color
#include "UnityEngine/Color.hpp"
// Including type: OVRPlugin/InsightPassthroughColorMapType
#include "GlobalNamespace/OVRPlugin_InsightPassthroughColorMapType.hpp"
// Including type: System.Runtime.InteropServices.GCHandle
#include "System/Runtime/InteropServices/GCHandle.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: GlobalNamespace
namespace GlobalNamespace {
  // Forward declaring type: OVRCameraRig
  class OVRCameraRig;
  // Skipping declaration: ColorMapEditorType because it is already included!
}
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Gradient
  class Gradient;
  // Forward declaring type: GameObject
  class GameObject;
  // Forward declaring type: Matrix4x4
  struct Matrix4x4;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: List`1<T>
  template<typename T>
  class List_1;
  // Forward declaring type: Dictionary`2<TKey, TValue>
  template<typename TKey, typename TValue>
  class Dictionary_2;
}
// Completed forward declares
// Type namespace: 
namespace GlobalNamespace {
  // Forward declaring type: OVRPassthroughLayer
  class OVRPassthroughLayer;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::GlobalNamespace::OVRPassthroughLayer);
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::OVRPassthroughLayer*, "", "OVRPassthroughLayer");
// Type namespace: 
namespace GlobalNamespace {
  // Size: 0xD5
  #pragma pack(push, 1)
  // Autogenerated type: OVRPassthroughLayer
  // [TokenAttribute] Offset: FFFFFFFF
  class OVRPassthroughLayer : public ::UnityEngine::MonoBehaviour {
    public:
    // Nested type: ::GlobalNamespace::OVRPassthroughLayer::ProjectionSurfaceType
    struct ProjectionSurfaceType;
    // Nested type: ::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType
    struct ColorMapEditorType;
    // Nested type: ::GlobalNamespace::OVRPassthroughLayer::PassthroughMeshInstance
    struct PassthroughMeshInstance;
    // Nested type: ::GlobalNamespace::OVRPassthroughLayer::DeferredPassthroughMeshAddition
    struct DeferredPassthroughMeshAddition;
    // Nested type: ::GlobalNamespace::OVRPassthroughLayer::$$c__DisplayClass9_0
    class $$c__DisplayClass9_0;
    // Nested type: ::GlobalNamespace::OVRPassthroughLayer::$$c__DisplayClass10_0
    class $$c__DisplayClass10_0;
    // Size: 0x14
    #pragma pack(push, 1)
    // Autogenerated type: OVRPassthroughLayer/ProjectionSurfaceType
    // [TokenAttribute] Offset: FFFFFFFF
    struct ProjectionSurfaceType/*, public ::System::Enum*/ {
      public:
      // Writing base type padding for base size: 0x0 to desired offset: 0x10
      char ___base_padding[0x10] = {};
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x10
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: ProjectionSurfaceType
      constexpr ProjectionSurfaceType(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator ::System::Enum
      operator ::System::Enum() noexcept {
        return *reinterpret_cast<::System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // static field const value: static public OVRPassthroughLayer/ProjectionSurfaceType Reconstructed
      static constexpr const int Reconstructed = 0;
      // Get static field: static public OVRPassthroughLayer/ProjectionSurfaceType Reconstructed
      static ::GlobalNamespace::OVRPassthroughLayer::ProjectionSurfaceType _get_Reconstructed();
      // Set static field: static public OVRPassthroughLayer/ProjectionSurfaceType Reconstructed
      static void _set_Reconstructed(::GlobalNamespace::OVRPassthroughLayer::ProjectionSurfaceType value);
      // static field const value: static public OVRPassthroughLayer/ProjectionSurfaceType UserDefined
      static constexpr const int UserDefined = 1;
      // Get static field: static public OVRPassthroughLayer/ProjectionSurfaceType UserDefined
      static ::GlobalNamespace::OVRPassthroughLayer::ProjectionSurfaceType _get_UserDefined();
      // Set static field: static public OVRPassthroughLayer/ProjectionSurfaceType UserDefined
      static void _set_UserDefined(::GlobalNamespace::OVRPassthroughLayer::ProjectionSurfaceType value);
      // Get instance field reference: public System.Int32 value__
      int& dyn_value__();
    }; // OVRPassthroughLayer/ProjectionSurfaceType
    #pragma pack(pop)
    static check_size<sizeof(OVRPassthroughLayer::ProjectionSurfaceType), 16 + sizeof(int)> __GlobalNamespace_OVRPassthroughLayer_ProjectionSurfaceTypeSizeCheck;
    static_assert(sizeof(OVRPassthroughLayer::ProjectionSurfaceType) == 0x14);
    // Size: 0x14
    #pragma pack(push, 1)
    // Autogenerated type: OVRPassthroughLayer/ColorMapEditorType
    // [TokenAttribute] Offset: FFFFFFFF
    struct ColorMapEditorType/*, public ::System::Enum*/ {
      public:
      // Writing base type padding for base size: 0x0 to desired offset: 0x10
      char ___base_padding[0x10] = {};
      public:
      // public System.Int32 value__
      // Size: 0x4
      // Offset: 0x10
      int value;
      // Field size check
      static_assert(sizeof(int) == 0x4);
      public:
      // Creating value type constructor for type: ColorMapEditorType
      constexpr ColorMapEditorType(int value_ = {}) noexcept : value{value_} {}
      // Creating interface conversion operator: operator ::System::Enum
      operator ::System::Enum() noexcept {
        return *reinterpret_cast<::System::Enum*>(this);
      }
      // Creating conversion operator: operator int
      constexpr operator int() const noexcept {
        return value;
      }
      // static field const value: static public OVRPassthroughLayer/ColorMapEditorType None
      static constexpr const int None = 0;
      // Get static field: static public OVRPassthroughLayer/ColorMapEditorType None
      static ::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType _get_None();
      // Set static field: static public OVRPassthroughLayer/ColorMapEditorType None
      static void _set_None(::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType value);
      // static field const value: static public OVRPassthroughLayer/ColorMapEditorType Controls
      static constexpr const int Controls = 1;
      // Get static field: static public OVRPassthroughLayer/ColorMapEditorType Controls
      static ::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType _get_Controls();
      // Set static field: static public OVRPassthroughLayer/ColorMapEditorType Controls
      static void _set_Controls(::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType value);
      // static field const value: static public OVRPassthroughLayer/ColorMapEditorType Custom
      static constexpr const int Custom = 2;
      // Get static field: static public OVRPassthroughLayer/ColorMapEditorType Custom
      static ::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType _get_Custom();
      // Set static field: static public OVRPassthroughLayer/ColorMapEditorType Custom
      static void _set_Custom(::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType value);
      // Get instance field reference: public System.Int32 value__
      int& dyn_value__();
    }; // OVRPassthroughLayer/ColorMapEditorType
    #pragma pack(pop)
    static check_size<sizeof(OVRPassthroughLayer::ColorMapEditorType), 16 + sizeof(int)> __GlobalNamespace_OVRPassthroughLayer_ColorMapEditorTypeSizeCheck;
    static_assert(sizeof(OVRPassthroughLayer::ColorMapEditorType) == 0x14);
    // Size: 0x11
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: OVRPassthroughLayer/PassthroughMeshInstance
    // [TokenAttribute] Offset: FFFFFFFF
    struct PassthroughMeshInstance/*, public ::System::ValueType*/ {
      public:
      public:
      // public System.UInt64 meshHandle
      // Size: 0x8
      // Offset: 0x0
      uint64_t meshHandle;
      // Field size check
      static_assert(sizeof(uint64_t) == 0x8);
      // public System.UInt64 instanceHandle
      // Size: 0x8
      // Offset: 0x8
      uint64_t instanceHandle;
      // Field size check
      static_assert(sizeof(uint64_t) == 0x8);
      // public System.Boolean updateTransform
      // Size: 0x1
      // Offset: 0x10
      bool updateTransform;
      // Field size check
      static_assert(sizeof(bool) == 0x1);
      public:
      // Creating value type constructor for type: PassthroughMeshInstance
      constexpr PassthroughMeshInstance(uint64_t meshHandle_ = {}, uint64_t instanceHandle_ = {}, bool updateTransform_ = {}) noexcept : meshHandle{meshHandle_}, instanceHandle{instanceHandle_}, updateTransform{updateTransform_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public System.UInt64 meshHandle
      uint64_t& dyn_meshHandle();
      // Get instance field reference: public System.UInt64 instanceHandle
      uint64_t& dyn_instanceHandle();
      // Get instance field reference: public System.Boolean updateTransform
      bool& dyn_updateTransform();
    }; // OVRPassthroughLayer/PassthroughMeshInstance
    #pragma pack(pop)
    static check_size<sizeof(OVRPassthroughLayer::PassthroughMeshInstance), 16 + sizeof(bool)> __GlobalNamespace_OVRPassthroughLayer_PassthroughMeshInstanceSizeCheck;
    static_assert(sizeof(OVRPassthroughLayer::PassthroughMeshInstance) == 0x11);
    // Size: 0x9
    #pragma pack(push, 1)
    // WARNING Layout: Sequential may not be correctly taken into account!
    // Autogenerated type: OVRPassthroughLayer/DeferredPassthroughMeshAddition
    // [TokenAttribute] Offset: FFFFFFFF
    struct DeferredPassthroughMeshAddition/*, public ::System::ValueType*/ {
      public:
      public:
      // public UnityEngine.GameObject gameObject
      // Size: 0x8
      // Offset: 0x0
      ::UnityEngine::GameObject* gameObject;
      // Field size check
      static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
      // public System.Boolean updateTransform
      // Size: 0x1
      // Offset: 0x8
      bool updateTransform;
      // Field size check
      static_assert(sizeof(bool) == 0x1);
      public:
      // Creating value type constructor for type: DeferredPassthroughMeshAddition
      constexpr DeferredPassthroughMeshAddition(::UnityEngine::GameObject* gameObject_ = {}, bool updateTransform_ = {}) noexcept : gameObject{gameObject_}, updateTransform{updateTransform_} {}
      // Creating interface conversion operator: operator ::System::ValueType
      operator ::System::ValueType() noexcept {
        return *reinterpret_cast<::System::ValueType*>(this);
      }
      // Get instance field reference: public UnityEngine.GameObject gameObject
      ::UnityEngine::GameObject*& dyn_gameObject();
      // Get instance field reference: public System.Boolean updateTransform
      bool& dyn_updateTransform();
    }; // OVRPassthroughLayer/DeferredPassthroughMeshAddition
    #pragma pack(pop)
    static check_size<sizeof(OVRPassthroughLayer::DeferredPassthroughMeshAddition), 8 + sizeof(bool)> __GlobalNamespace_OVRPassthroughLayer_DeferredPassthroughMeshAdditionSizeCheck;
    static_assert(sizeof(OVRPassthroughLayer::DeferredPassthroughMeshAddition) == 0x9);
    #ifdef USE_CODEGEN_FIELDS
    public:
    #else
    #ifdef CODEGEN_FIELD_ACCESSIBILITY
    CODEGEN_FIELD_ACCESSIBILITY:
    #else
    protected:
    #endif
    #endif
    // public OVRPassthroughLayer/ProjectionSurfaceType projectionSurfaceType
    // Size: 0x14
    // Offset: 0x18
    ::GlobalNamespace::OVRPassthroughLayer::ProjectionSurfaceType projectionSurfaceType;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::OVRPassthroughLayer::ProjectionSurfaceType) == 0x14);
    // public OVROverlay/OverlayType overlayType
    // Size: 0x14
    // Offset: 0x1C
    ::GlobalNamespace::OVROverlay::OverlayType overlayType;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::OVROverlay::OverlayType) == 0x14);
    // public System.Int32 compositionDepth
    // Size: 0x4
    // Offset: 0x20
    int compositionDepth;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // public System.Boolean hidden
    // Size: 0x1
    // Offset: 0x24
    bool hidden;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean overridePerLayerColorScaleAndOffset
    // Size: 0x1
    // Offset: 0x25
    bool overridePerLayerColorScaleAndOffset;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: overridePerLayerColorScaleAndOffset and: colorScale
    char __padding4[0x2] = {};
    // public UnityEngine.Vector4 colorScale
    // Size: 0x10
    // Offset: 0x28
    ::UnityEngine::Vector4 colorScale;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector4) == 0x10);
    // public UnityEngine.Vector4 colorOffset
    // Size: 0x10
    // Offset: 0x38
    ::UnityEngine::Vector4 colorOffset;
    // Field size check
    static_assert(sizeof(::UnityEngine::Vector4) == 0x10);
    // private OVRPassthroughLayer/ColorMapEditorType colorMapEditorType_
    // Size: 0x14
    // Offset: 0x48
    ::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType colorMapEditorType;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType) == 0x14);
    // public UnityEngine.Gradient colorMapEditorGradient
    // Size: 0x8
    // Offset: 0x50
    ::UnityEngine::Gradient* colorMapEditorGradient;
    // Field size check
    static_assert(sizeof(::UnityEngine::Gradient*) == 0x8);
    // private UnityEngine.Gradient colorMapEditorGradientOld
    // Size: 0x8
    // Offset: 0x58
    ::UnityEngine::Gradient* colorMapEditorGradientOld;
    // Field size check
    static_assert(sizeof(::UnityEngine::Gradient*) == 0x8);
    // public System.Single colorMapEditorContrast
    // Size: 0x4
    // Offset: 0x60
    float colorMapEditorContrast;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single colorMapEditorContrast_
    // Size: 0x4
    // Offset: 0x64
    float colorMapEditorContrast;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single colorMapEditorBrightness
    // Size: 0x4
    // Offset: 0x68
    float colorMapEditorBrightness;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single colorMapEditorBrightness_
    // Size: 0x4
    // Offset: 0x6C
    float colorMapEditorBrightness;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public System.Single colorMapEditorPosterize
    // Size: 0x4
    // Offset: 0x70
    float colorMapEditorPosterize;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single colorMapEditorPosterize_
    // Size: 0x4
    // Offset: 0x74
    float colorMapEditorPosterize;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private OVRCameraRig cameraRig
    // Size: 0x8
    // Offset: 0x78
    ::GlobalNamespace::OVRCameraRig* cameraRig;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::OVRCameraRig*) == 0x8);
    // private System.Boolean cameraRigInitialized
    // Size: 0x1
    // Offset: 0x80
    bool cameraRigInitialized;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: cameraRigInitialized and: auxGameObject
    char __padding17[0x7] = {};
    // private UnityEngine.GameObject auxGameObject
    // Size: 0x8
    // Offset: 0x88
    ::UnityEngine::GameObject* auxGameObject;
    // Field size check
    static_assert(sizeof(::UnityEngine::GameObject*) == 0x8);
    // private OVROverlay passthroughOverlay
    // Size: 0x8
    // Offset: 0x90
    ::GlobalNamespace::OVROverlay* passthroughOverlay;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::OVROverlay*) == 0x8);
    // private System.Collections.Generic.Dictionary`2<UnityEngine.GameObject,OVRPassthroughLayer/PassthroughMeshInstance> surfaceGameObjects
    // Size: 0x8
    // Offset: 0x98
    ::System::Collections::Generic::Dictionary_2<::UnityEngine::GameObject*, ::GlobalNamespace::OVRPassthroughLayer::PassthroughMeshInstance>* surfaceGameObjects;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::Dictionary_2<::UnityEngine::GameObject*, ::GlobalNamespace::OVRPassthroughLayer::PassthroughMeshInstance>*) == 0x8);
    // private System.Collections.Generic.List`1<OVRPassthroughLayer/DeferredPassthroughMeshAddition> deferredSurfaceGameObjects
    // Size: 0x8
    // Offset: 0xA0
    ::System::Collections::Generic::List_1<::GlobalNamespace::OVRPassthroughLayer::DeferredPassthroughMeshAddition>* deferredSurfaceGameObjects;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::GlobalNamespace::OVRPassthroughLayer::DeferredPassthroughMeshAddition>*) == 0x8);
    // private System.Single textureOpacity_
    // Size: 0x4
    // Offset: 0xA8
    float textureOpacity;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Boolean edgeRenderingEnabled_
    // Size: 0x1
    // Offset: 0xAC
    bool edgeRenderingEnabled;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: edgeRenderingEnabled and: edgeColor
    char __padding23[0x3] = {};
    // private UnityEngine.Color edgeColor_
    // Size: 0x10
    // Offset: 0xB0
    ::UnityEngine::Color edgeColor;
    // Field size check
    static_assert(sizeof(::UnityEngine::Color) == 0x10);
    // private OVRPlugin/InsightPassthroughColorMapType colorMapType
    // Size: 0x14
    // Offset: 0xC0
    ::GlobalNamespace::OVRPlugin::InsightPassthroughColorMapType colorMapType;
    // Field size check
    static_assert(sizeof(::GlobalNamespace::OVRPlugin::InsightPassthroughColorMapType) == 0x14);
    // private System.Byte[] colorMapData
    // Size: 0x8
    // Offset: 0xC8
    ::ArrayW<uint8_t> colorMapData;
    // Field size check
    static_assert(sizeof(::ArrayW<uint8_t>) == 0x8);
    // private System.Runtime.InteropServices.GCHandle colorMapDataHandle
    // Size: 0x4
    // Offset: 0xD0
    ::System::Runtime::InteropServices::GCHandle colorMapDataHandle;
    // Field size check
    static_assert(sizeof(::System::Runtime::InteropServices::GCHandle) == 0x4);
    // private System.Boolean styleDirty
    // Size: 0x1
    // Offset: 0xD4
    bool styleDirty;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    public:
    // Deleting conversion operator: operator ::System::IntPtr
    constexpr operator ::System::IntPtr() const noexcept = delete;
    // Get static field: static private readonly UnityEngine.Gradient colorMapNeutralGradient
    static ::UnityEngine::Gradient* _get_colorMapNeutralGradient();
    // Set static field: static private readonly UnityEngine.Gradient colorMapNeutralGradient
    static void _set_colorMapNeutralGradient(::UnityEngine::Gradient* value);
    // Get instance field reference: public OVRPassthroughLayer/ProjectionSurfaceType projectionSurfaceType
    ::GlobalNamespace::OVRPassthroughLayer::ProjectionSurfaceType& dyn_projectionSurfaceType();
    // Get instance field reference: public OVROverlay/OverlayType overlayType
    ::GlobalNamespace::OVROverlay::OverlayType& dyn_overlayType();
    // Get instance field reference: public System.Int32 compositionDepth
    int& dyn_compositionDepth();
    // Get instance field reference: public System.Boolean hidden
    bool& dyn_hidden();
    // Get instance field reference: public System.Boolean overridePerLayerColorScaleAndOffset
    bool& dyn_overridePerLayerColorScaleAndOffset();
    // Get instance field reference: public UnityEngine.Vector4 colorScale
    ::UnityEngine::Vector4& dyn_colorScale();
    // Get instance field reference: public UnityEngine.Vector4 colorOffset
    ::UnityEngine::Vector4& dyn_colorOffset();
    // Get instance field reference: private OVRPassthroughLayer/ColorMapEditorType colorMapEditorType_
    ::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType& dyn_colorMapEditorType_();
    // Get instance field reference: public UnityEngine.Gradient colorMapEditorGradient
    ::UnityEngine::Gradient*& dyn_colorMapEditorGradient();
    // Get instance field reference: private UnityEngine.Gradient colorMapEditorGradientOld
    ::UnityEngine::Gradient*& dyn_colorMapEditorGradientOld();
    // Get instance field reference: public System.Single colorMapEditorContrast
    float& dyn_colorMapEditorContrast();
    // Get instance field reference: private System.Single colorMapEditorContrast_
    float& dyn_colorMapEditorContrast_();
    // Get instance field reference: public System.Single colorMapEditorBrightness
    float& dyn_colorMapEditorBrightness();
    // Get instance field reference: private System.Single colorMapEditorBrightness_
    float& dyn_colorMapEditorBrightness_();
    // Get instance field reference: public System.Single colorMapEditorPosterize
    float& dyn_colorMapEditorPosterize();
    // Get instance field reference: private System.Single colorMapEditorPosterize_
    float& dyn_colorMapEditorPosterize_();
    // Get instance field reference: private OVRCameraRig cameraRig
    ::GlobalNamespace::OVRCameraRig*& dyn_cameraRig();
    // Get instance field reference: private System.Boolean cameraRigInitialized
    bool& dyn_cameraRigInitialized();
    // Get instance field reference: private UnityEngine.GameObject auxGameObject
    ::UnityEngine::GameObject*& dyn_auxGameObject();
    // Get instance field reference: private OVROverlay passthroughOverlay
    ::GlobalNamespace::OVROverlay*& dyn_passthroughOverlay();
    // Get instance field reference: private System.Collections.Generic.Dictionary`2<UnityEngine.GameObject,OVRPassthroughLayer/PassthroughMeshInstance> surfaceGameObjects
    ::System::Collections::Generic::Dictionary_2<::UnityEngine::GameObject*, ::GlobalNamespace::OVRPassthroughLayer::PassthroughMeshInstance>*& dyn_surfaceGameObjects();
    // Get instance field reference: private System.Collections.Generic.List`1<OVRPassthroughLayer/DeferredPassthroughMeshAddition> deferredSurfaceGameObjects
    ::System::Collections::Generic::List_1<::GlobalNamespace::OVRPassthroughLayer::DeferredPassthroughMeshAddition>*& dyn_deferredSurfaceGameObjects();
    // Get instance field reference: private System.Single textureOpacity_
    float& dyn_textureOpacity_();
    // Get instance field reference: private System.Boolean edgeRenderingEnabled_
    bool& dyn_edgeRenderingEnabled_();
    // Get instance field reference: private UnityEngine.Color edgeColor_
    ::UnityEngine::Color& dyn_edgeColor_();
    // Get instance field reference: private OVRPlugin/InsightPassthroughColorMapType colorMapType
    ::GlobalNamespace::OVRPlugin::InsightPassthroughColorMapType& dyn_colorMapType();
    // Get instance field reference: private System.Byte[] colorMapData
    ::ArrayW<uint8_t>& dyn_colorMapData();
    // Get instance field reference: private System.Runtime.InteropServices.GCHandle colorMapDataHandle
    ::System::Runtime::InteropServices::GCHandle& dyn_colorMapDataHandle();
    // Get instance field reference: private System.Boolean styleDirty
    bool& dyn_styleDirty();
    // public System.Single get_textureOpacity()
    // Offset: 0xB98150
    float get_textureOpacity();
    // public System.Void set_textureOpacity(System.Single value)
    // Offset: 0xB98158
    void set_textureOpacity(float value);
    // public System.Boolean get_edgeRenderingEnabled()
    // Offset: 0xB98174
    bool get_edgeRenderingEnabled();
    // public System.Void set_edgeRenderingEnabled(System.Boolean value)
    // Offset: 0xB9817C
    void set_edgeRenderingEnabled(bool value);
    // public UnityEngine.Color get_edgeColor()
    // Offset: 0xB981A4
    ::UnityEngine::Color get_edgeColor();
    // public System.Void set_edgeColor(UnityEngine.Color value)
    // Offset: 0xB981B0
    void set_edgeColor(::UnityEngine::Color value);
    // public OVRPassthroughLayer/ColorMapEditorType get_colorMapEditorType()
    // Offset: 0xB98908
    ::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType get_colorMapEditorType();
    // public System.Void set_colorMapEditorType(OVRPassthroughLayer/ColorMapEditorType value)
    // Offset: 0xB98300
    void set_colorMapEditorType(::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType value);
    // private OVROverlay/OverlayShape get_overlayShape()
    // Offset: 0xB99DBC
    ::GlobalNamespace::OVROverlay::OverlayShape get_overlayShape();
    // public System.Void AddSurfaceGeometry(UnityEngine.GameObject obj, System.Boolean updateTransform)
    // Offset: 0xB979C4
    void AddSurfaceGeometry(::UnityEngine::GameObject* obj, bool updateTransform);
    // public System.Void RemoveSurfaceGeometry(UnityEngine.GameObject obj)
    // Offset: 0xB97B9C
    void RemoveSurfaceGeometry(::UnityEngine::GameObject* obj);
    // public System.Boolean IsSurfaceGeometry(UnityEngine.GameObject obj)
    // Offset: 0xB98020
    bool IsSurfaceGeometry(::UnityEngine::GameObject* obj);
    // public System.Void SetColorMap(UnityEngine.Color[] values)
    // Offset: 0xB98210
    void SetColorMap(::ArrayW<::UnityEngine::Color> values);
    // public System.Void SetColorMapControls(System.Single contrast, System.Single brightness, System.Single posterize, UnityEngine.Gradient gradient)
    // Offset: 0xB984FC
    void SetColorMapControls(float contrast, float brightness, float posterize, ::UnityEngine::Gradient* gradient);
    // public System.Void SetColorMapMonochromatic(System.Byte[] values)
    // Offset: 0xB98810
    void SetColorMapMonochromatic(::ArrayW<uint8_t> values);
    // public System.Void DisableColorMap()
    // Offset: 0xB988D0
    void DisableColorMap();
    // private System.Void AddDeferredSurfaceGeometries()
    // Offset: 0xB98C4C
    void AddDeferredSurfaceGeometries();
    // private UnityEngine.Matrix4x4 GetTransformMatrixForPassthroughSurfaceObject(UnityEngine.GameObject obj)
    // Offset: 0xB990DC
    ::UnityEngine::Matrix4x4 GetTransformMatrixForPassthroughSurfaceObject(::UnityEngine::GameObject* obj);
    // private System.Boolean CreateAndAddMesh(UnityEngine.GameObject obj, out System.UInt64 meshHandle, out System.UInt64 instanceHandle)
    // Offset: 0xB98E34
    bool CreateAndAddMesh(::UnityEngine::GameObject* obj, ByRef<uint64_t> meshHandle, ByRef<uint64_t> instanceHandle);
    // private System.Void DestroySurfaceGeometries(System.Boolean addBackToDeferredQueue)
    // Offset: 0xB996A0
    void DestroySurfaceGeometries(bool addBackToDeferredQueue);
    // private System.Void UpdateSurfaceGeometryTransforms()
    // Offset: 0xB998B8
    void UpdateSurfaceGeometryTransforms();
    // private System.Void AllocateColorMapData()
    // Offset: 0xB98364
    void AllocateColorMapData();
    // private System.Void DeallocateColorMapData()
    // Offset: 0xB98910
    void DeallocateColorMapData();
    // static private UnityEngine.Gradient CreateNeutralColorMapGradient()
    // Offset: 0xB98600
    static ::UnityEngine::Gradient* CreateNeutralColorMapGradient();
    // private System.Void UpdateColorMapFromControls(System.Boolean forceUpdate)
    // Offset: 0xB989BC
    void UpdateColorMapFromControls(bool forceUpdate);
    // private System.Void WriteColorToColorMap(System.Int32 colorIndex, ref UnityEngine.Color color)
    // Offset: 0xB98430
    void WriteColorToColorMap(int colorIndex, ByRef<::UnityEngine::Color> color);
    // private System.Void SyncToOverlay()
    // Offset: 0xB99C3C
    void SyncToOverlay();
    // private System.Void Update()
    // Offset: 0xB99DD0
    void Update();
    // private System.Void LateUpdate()
    // Offset: 0xB99DD4
    void LateUpdate();
    // private System.Void OnEnable()
    // Offset: 0xB9A1A8
    void OnEnable();
    // private System.Void OnDisable()
    // Offset: 0xB9A2A4
    void OnDisable();
    // private System.Void OnDestroy()
    // Offset: 0xB9A398
    void OnDestroy();
    // public System.Void .ctor()
    // Offset: 0xB9A3A0
    // Implemented from: UnityEngine.MonoBehaviour
    // Base method: System.Void MonoBehaviour::.ctor()
    // Base method: System.Void Behaviour::.ctor()
    // Base method: System.Void Component::.ctor()
    // Base method: System.Void Object::.ctor()
    // Base method: System.Void Object::.ctor()
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static OVRPassthroughLayer* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::GlobalNamespace::OVRPassthroughLayer::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<OVRPassthroughLayer*, creationType>()));
    }
    // static private System.Void .cctor()
    // Offset: 0xB9A524
    // Implemented from: UnityEngine.Object
    // Base method: System.Void Object::.cctor()
    static void _cctor();
  }; // OVRPassthroughLayer
  #pragma pack(pop)
  static check_size<sizeof(OVRPassthroughLayer), 212 + sizeof(bool)> __GlobalNamespace_OVRPassthroughLayerSizeCheck;
  static_assert(sizeof(OVRPassthroughLayer) == 0xD5);
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::OVRPassthroughLayer::DeferredPassthroughMeshAddition, "", "OVRPassthroughLayer/DeferredPassthroughMeshAddition");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::OVRPassthroughLayer::PassthroughMeshInstance, "", "OVRPassthroughLayer/PassthroughMeshInstance");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType, "", "OVRPassthroughLayer/ColorMapEditorType");
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
DEFINE_IL2CPP_ARG_TYPE(::GlobalNamespace::OVRPassthroughLayer::ProjectionSurfaceType, "", "OVRPassthroughLayer/ProjectionSurfaceType");
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::get_textureOpacity
// Il2CppName: get_textureOpacity
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<float (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::get_textureOpacity)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "get_textureOpacity", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::set_textureOpacity
// Il2CppName: set_textureOpacity
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)(float)>(&GlobalNamespace::OVRPassthroughLayer::set_textureOpacity)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "set_textureOpacity", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::get_edgeRenderingEnabled
// Il2CppName: get_edgeRenderingEnabled
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::get_edgeRenderingEnabled)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "get_edgeRenderingEnabled", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::set_edgeRenderingEnabled
// Il2CppName: set_edgeRenderingEnabled
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)(bool)>(&GlobalNamespace::OVRPassthroughLayer::set_edgeRenderingEnabled)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "set_edgeRenderingEnabled", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::get_edgeColor
// Il2CppName: get_edgeColor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Color (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::get_edgeColor)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "get_edgeColor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::set_edgeColor
// Il2CppName: set_edgeColor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)(::UnityEngine::Color)>(&GlobalNamespace::OVRPassthroughLayer::set_edgeColor)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("UnityEngine", "Color")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "set_edgeColor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::get_colorMapEditorType
// Il2CppName: get_colorMapEditorType
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::get_colorMapEditorType)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "get_colorMapEditorType", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::set_colorMapEditorType
// Il2CppName: set_colorMapEditorType
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)(::GlobalNamespace::OVRPassthroughLayer::ColorMapEditorType)>(&GlobalNamespace::OVRPassthroughLayer::set_colorMapEditorType)> {
  static const MethodInfo* get() {
    static auto* value = &::il2cpp_utils::GetClassFromName("", "OVRPassthroughLayer/ColorMapEditorType")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "set_colorMapEditorType", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{value});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::get_overlayShape
// Il2CppName: get_overlayShape
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::GlobalNamespace::OVROverlay::OverlayShape (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::get_overlayShape)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "get_overlayShape", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::AddSurfaceGeometry
// Il2CppName: AddSurfaceGeometry
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)(::UnityEngine::GameObject*, bool)>(&GlobalNamespace::OVRPassthroughLayer::AddSurfaceGeometry)> {
  static const MethodInfo* get() {
    static auto* obj = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    static auto* updateTransform = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "AddSurfaceGeometry", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{obj, updateTransform});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::RemoveSurfaceGeometry
// Il2CppName: RemoveSurfaceGeometry
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)(::UnityEngine::GameObject*)>(&GlobalNamespace::OVRPassthroughLayer::RemoveSurfaceGeometry)> {
  static const MethodInfo* get() {
    static auto* obj = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "RemoveSurfaceGeometry", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{obj});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::IsSurfaceGeometry
// Il2CppName: IsSurfaceGeometry
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::OVRPassthroughLayer::*)(::UnityEngine::GameObject*)>(&GlobalNamespace::OVRPassthroughLayer::IsSurfaceGeometry)> {
  static const MethodInfo* get() {
    static auto* obj = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "IsSurfaceGeometry", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{obj});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::SetColorMap
// Il2CppName: SetColorMap
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)(::ArrayW<::UnityEngine::Color>)>(&GlobalNamespace::OVRPassthroughLayer::SetColorMap)> {
  static const MethodInfo* get() {
    static auto* values = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("UnityEngine", "Color"), 1)->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "SetColorMap", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{values});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::SetColorMapControls
// Il2CppName: SetColorMapControls
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)(float, float, float, ::UnityEngine::Gradient*)>(&GlobalNamespace::OVRPassthroughLayer::SetColorMapControls)> {
  static const MethodInfo* get() {
    static auto* contrast = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* brightness = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* posterize = &::il2cpp_utils::GetClassFromName("System", "Single")->byval_arg;
    static auto* gradient = &::il2cpp_utils::GetClassFromName("UnityEngine", "Gradient")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "SetColorMapControls", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{contrast, brightness, posterize, gradient});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::SetColorMapMonochromatic
// Il2CppName: SetColorMapMonochromatic
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)(::ArrayW<uint8_t>)>(&GlobalNamespace::OVRPassthroughLayer::SetColorMapMonochromatic)> {
  static const MethodInfo* get() {
    static auto* values = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System", "Byte"), 1)->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "SetColorMapMonochromatic", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{values});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::DisableColorMap
// Il2CppName: DisableColorMap
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::DisableColorMap)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "DisableColorMap", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::AddDeferredSurfaceGeometries
// Il2CppName: AddDeferredSurfaceGeometries
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::AddDeferredSurfaceGeometries)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "AddDeferredSurfaceGeometries", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::GetTransformMatrixForPassthroughSurfaceObject
// Il2CppName: GetTransformMatrixForPassthroughSurfaceObject
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Matrix4x4 (GlobalNamespace::OVRPassthroughLayer::*)(::UnityEngine::GameObject*)>(&GlobalNamespace::OVRPassthroughLayer::GetTransformMatrixForPassthroughSurfaceObject)> {
  static const MethodInfo* get() {
    static auto* obj = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "GetTransformMatrixForPassthroughSurfaceObject", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{obj});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::CreateAndAddMesh
// Il2CppName: CreateAndAddMesh
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (GlobalNamespace::OVRPassthroughLayer::*)(::UnityEngine::GameObject*, ByRef<uint64_t>, ByRef<uint64_t>)>(&GlobalNamespace::OVRPassthroughLayer::CreateAndAddMesh)> {
  static const MethodInfo* get() {
    static auto* obj = &::il2cpp_utils::GetClassFromName("UnityEngine", "GameObject")->byval_arg;
    static auto* meshHandle = &::il2cpp_utils::GetClassFromName("System", "UInt64")->this_arg;
    static auto* instanceHandle = &::il2cpp_utils::GetClassFromName("System", "UInt64")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "CreateAndAddMesh", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{obj, meshHandle, instanceHandle});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::DestroySurfaceGeometries
// Il2CppName: DestroySurfaceGeometries
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)(bool)>(&GlobalNamespace::OVRPassthroughLayer::DestroySurfaceGeometries)> {
  static const MethodInfo* get() {
    static auto* addBackToDeferredQueue = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "DestroySurfaceGeometries", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{addBackToDeferredQueue});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::UpdateSurfaceGeometryTransforms
// Il2CppName: UpdateSurfaceGeometryTransforms
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::UpdateSurfaceGeometryTransforms)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "UpdateSurfaceGeometryTransforms", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::AllocateColorMapData
// Il2CppName: AllocateColorMapData
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::AllocateColorMapData)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "AllocateColorMapData", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::DeallocateColorMapData
// Il2CppName: DeallocateColorMapData
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::DeallocateColorMapData)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "DeallocateColorMapData", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::CreateNeutralColorMapGradient
// Il2CppName: CreateNeutralColorMapGradient
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::UnityEngine::Gradient* (*)()>(&GlobalNamespace::OVRPassthroughLayer::CreateNeutralColorMapGradient)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "CreateNeutralColorMapGradient", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::UpdateColorMapFromControls
// Il2CppName: UpdateColorMapFromControls
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)(bool)>(&GlobalNamespace::OVRPassthroughLayer::UpdateColorMapFromControls)> {
  static const MethodInfo* get() {
    static auto* forceUpdate = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "UpdateColorMapFromControls", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{forceUpdate});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::WriteColorToColorMap
// Il2CppName: WriteColorToColorMap
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)(int, ByRef<::UnityEngine::Color>)>(&GlobalNamespace::OVRPassthroughLayer::WriteColorToColorMap)> {
  static const MethodInfo* get() {
    static auto* colorIndex = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    static auto* color = &::il2cpp_utils::GetClassFromName("UnityEngine", "Color")->this_arg;
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "WriteColorToColorMap", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{colorIndex, color});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::SyncToOverlay
// Il2CppName: SyncToOverlay
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::SyncToOverlay)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "SyncToOverlay", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::Update
// Il2CppName: Update
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::Update)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "Update", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::LateUpdate
// Il2CppName: LateUpdate
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::LateUpdate)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "LateUpdate", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::OnEnable
// Il2CppName: OnEnable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::OnEnable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "OnEnable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::OnDisable
// Il2CppName: OnDisable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::OnDisable)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "OnDisable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::OnDestroy
// Il2CppName: OnDestroy
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (GlobalNamespace::OVRPassthroughLayer::*)()>(&GlobalNamespace::OVRPassthroughLayer::OnDestroy)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), "OnDestroy", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: GlobalNamespace::OVRPassthroughLayer::_cctor
// Il2CppName: .cctor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&GlobalNamespace::OVRPassthroughLayer::_cctor)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(GlobalNamespace::OVRPassthroughLayer*), ".cctor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
