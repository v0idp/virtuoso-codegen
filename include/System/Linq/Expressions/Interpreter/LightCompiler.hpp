// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "beatsaber-hook/shared/utils/typedefs.h"
#include "beatsaber-hook/shared/utils/byref.hpp"
// Including type: System.Linq.Expressions.Interpreter.LocalDefinition
#include "System/Linq/Expressions/Interpreter/LocalDefinition.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "beatsaber-hook/shared/utils/utils.h"
#include "beatsaber-hook/shared/utils/typedefs-array.hpp"
#include "beatsaber-hook/shared/utils/typedefs-string.hpp"
// Completed includes
// Begin forward declares
// Forward declaring namespace: System::Linq::Expressions::Interpreter
namespace System::Linq::Expressions::Interpreter {
  // Forward declaring type: InstructionList
  class InstructionList;
  // Forward declaring type: LocalVariables
  class LocalVariables;
  // Forward declaring type: DebugInfo
  class DebugInfo;
  // Forward declaring type: HybridReferenceDictionary`2<TKey, TValue>
  template<typename TKey, typename TValue>
  class HybridReferenceDictionary_2;
  // Forward declaring type: LabelInfo
  class LabelInfo;
  // Forward declaring type: LabelScopeInfo
  class LabelScopeInfo;
  // Forward declaring type: LightDelegateCreator
  class LightDelegateCreator;
  // Forward declaring type: Interpreter
  class Interpreter;
  // Forward declaring type: LocalVariable
  class LocalVariable;
  // Forward declaring type: LabelScopeKind
  struct LabelScopeKind;
  // Forward declaring type: ByRefUpdater
  class ByRefUpdater;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: List`1<T>
  template<typename T>
  class List_1;
  // Forward declaring type: Stack`1<T>
  template<typename T>
  class Stack_1;
}
// Forward declaring namespace: System::Linq::Expressions
namespace System::Linq::Expressions {
  // Forward declaring type: LabelTarget
  class LabelTarget;
  // Forward declaring type: ParameterExpression
  class ParameterExpression;
  // Forward declaring type: StackGuard
  class StackGuard;
  // Forward declaring type: LambdaExpression
  class LambdaExpression;
  // Forward declaring type: Expression
  class Expression;
  // Forward declaring type: BlockExpression
  class BlockExpression;
  // Forward declaring type: IndexExpression
  class IndexExpression;
  // Forward declaring type: BinaryExpression
  class BinaryExpression;
  // Forward declaring type: ExpressionType
  struct ExpressionType;
  // Forward declaring type: UnaryExpression
  class UnaryExpression;
  // Forward declaring type: SwitchExpression
  class SwitchExpression;
  // Forward declaring type: TryExpression
  class TryExpression;
  // Forward declaring type: IArgumentProvider
  class IArgumentProvider;
  // Forward declaring type: ElementInit
  class ElementInit;
  // Forward declaring type: MemberBinding
  class MemberBinding;
}
// Forward declaring namespace: System
namespace System {
  // Forward declaring type: Type
  class Type;
}
// Forward declaring namespace: System::Reflection
namespace System::Reflection {
  // Forward declaring type: MemberInfo
  class MemberInfo;
  // Forward declaring type: MethodInfo
  class MethodInfo;
}
// Forward declaring namespace: System::Collections::ObjectModel
namespace System::Collections::ObjectModel {
  // Forward declaring type: ReadOnlyCollection`1<T>
  template<typename T>
  class ReadOnlyCollection_1;
}
// Completed forward declares
// Type namespace: System.Linq.Expressions.Interpreter
namespace System::Linq::Expressions::Interpreter {
  // Forward declaring type: LightCompiler
  class LightCompiler;
}
#include "beatsaber-hook/shared/utils/il2cpp-type-check.hpp"
NEED_NO_BOX(::System::Linq::Expressions::Interpreter::LightCompiler);
DEFINE_IL2CPP_ARG_TYPE(::System::Linq::Expressions::Interpreter::LightCompiler*, "System.Linq.Expressions.Interpreter", "LightCompiler");
// Type namespace: System.Linq.Expressions.Interpreter
namespace System::Linq::Expressions::Interpreter {
  // Size: 0x50
  #pragma pack(push, 1)
  // Autogenerated type: System.Linq.Expressions.Interpreter.LightCompiler
  // [TokenAttribute] Offset: FFFFFFFF
  class LightCompiler : public ::Il2CppObject {
    public:
    // Nested type: ::System::Linq::Expressions::Interpreter::LightCompiler::QuoteVisitor
    class QuoteVisitor;
    // Nested type: ::System::Linq::Expressions::Interpreter::LightCompiler::$$c
    class $$c;
    public:
    // private readonly System.Linq.Expressions.Interpreter.InstructionList _instructions
    // Size: 0x8
    // Offset: 0x10
    ::System::Linq::Expressions::Interpreter::InstructionList* instructions;
    // Field size check
    static_assert(sizeof(::System::Linq::Expressions::Interpreter::InstructionList*) == 0x8);
    // private readonly System.Linq.Expressions.Interpreter.LocalVariables _locals
    // Size: 0x8
    // Offset: 0x18
    ::System::Linq::Expressions::Interpreter::LocalVariables* locals;
    // Field size check
    static_assert(sizeof(::System::Linq::Expressions::Interpreter::LocalVariables*) == 0x8);
    // private readonly System.Collections.Generic.List`1<System.Linq.Expressions.Interpreter.DebugInfo> _debugInfos
    // Size: 0x8
    // Offset: 0x20
    ::System::Collections::Generic::List_1<::System::Linq::Expressions::Interpreter::DebugInfo*>* debugInfos;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::List_1<::System::Linq::Expressions::Interpreter::DebugInfo*>*) == 0x8);
    // private readonly System.Linq.Expressions.Interpreter.HybridReferenceDictionary`2<System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Interpreter.LabelInfo> _treeLabels
    // Size: 0x8
    // Offset: 0x28
    ::System::Linq::Expressions::Interpreter::HybridReferenceDictionary_2<::System::Linq::Expressions::LabelTarget*, ::System::Linq::Expressions::Interpreter::LabelInfo*>* treeLabels;
    // Field size check
    static_assert(sizeof(::System::Linq::Expressions::Interpreter::HybridReferenceDictionary_2<::System::Linq::Expressions::LabelTarget*, ::System::Linq::Expressions::Interpreter::LabelInfo*>*) == 0x8);
    // private System.Linq.Expressions.Interpreter.LabelScopeInfo _labelBlock
    // Size: 0x8
    // Offset: 0x30
    ::System::Linq::Expressions::Interpreter::LabelScopeInfo* labelBlock;
    // Field size check
    static_assert(sizeof(::System::Linq::Expressions::Interpreter::LabelScopeInfo*) == 0x8);
    // private readonly System.Collections.Generic.Stack`1<System.Linq.Expressions.ParameterExpression> _exceptionForRethrowStack
    // Size: 0x8
    // Offset: 0x38
    ::System::Collections::Generic::Stack_1<::System::Linq::Expressions::ParameterExpression*>* exceptionForRethrowStack;
    // Field size check
    static_assert(sizeof(::System::Collections::Generic::Stack_1<::System::Linq::Expressions::ParameterExpression*>*) == 0x8);
    // private readonly System.Linq.Expressions.Interpreter.LightCompiler _parent
    // Size: 0x8
    // Offset: 0x40
    ::System::Linq::Expressions::Interpreter::LightCompiler* parent;
    // Field size check
    static_assert(sizeof(::System::Linq::Expressions::Interpreter::LightCompiler*) == 0x8);
    // private readonly System.Linq.Expressions.StackGuard _guard
    // Size: 0x8
    // Offset: 0x48
    ::System::Linq::Expressions::StackGuard* guard;
    // Field size check
    static_assert(sizeof(::System::Linq::Expressions::StackGuard*) == 0x8);
    public:
    // Get static field: static private readonly System.Linq.Expressions.Interpreter.LocalDefinition[] s_emptyLocals
    static ::ArrayW<::System::Linq::Expressions::Interpreter::LocalDefinition> _get_s_emptyLocals();
    // Set static field: static private readonly System.Linq.Expressions.Interpreter.LocalDefinition[] s_emptyLocals
    static void _set_s_emptyLocals(::ArrayW<::System::Linq::Expressions::Interpreter::LocalDefinition> value);
    // Get instance field reference: private readonly System.Linq.Expressions.Interpreter.InstructionList _instructions
    [[deprecated("Use field access instead!")]] ::System::Linq::Expressions::Interpreter::InstructionList*& dyn__instructions();
    // Get instance field reference: private readonly System.Linq.Expressions.Interpreter.LocalVariables _locals
    [[deprecated("Use field access instead!")]] ::System::Linq::Expressions::Interpreter::LocalVariables*& dyn__locals();
    // Get instance field reference: private readonly System.Collections.Generic.List`1<System.Linq.Expressions.Interpreter.DebugInfo> _debugInfos
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::List_1<::System::Linq::Expressions::Interpreter::DebugInfo*>*& dyn__debugInfos();
    // Get instance field reference: private readonly System.Linq.Expressions.Interpreter.HybridReferenceDictionary`2<System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Interpreter.LabelInfo> _treeLabels
    [[deprecated("Use field access instead!")]] ::System::Linq::Expressions::Interpreter::HybridReferenceDictionary_2<::System::Linq::Expressions::LabelTarget*, ::System::Linq::Expressions::Interpreter::LabelInfo*>*& dyn__treeLabels();
    // Get instance field reference: private System.Linq.Expressions.Interpreter.LabelScopeInfo _labelBlock
    [[deprecated("Use field access instead!")]] ::System::Linq::Expressions::Interpreter::LabelScopeInfo*& dyn__labelBlock();
    // Get instance field reference: private readonly System.Collections.Generic.Stack`1<System.Linq.Expressions.ParameterExpression> _exceptionForRethrowStack
    [[deprecated("Use field access instead!")]] ::System::Collections::Generic::Stack_1<::System::Linq::Expressions::ParameterExpression*>*& dyn__exceptionForRethrowStack();
    // Get instance field reference: private readonly System.Linq.Expressions.Interpreter.LightCompiler _parent
    [[deprecated("Use field access instead!")]] ::System::Linq::Expressions::Interpreter::LightCompiler*& dyn__parent();
    // Get instance field reference: private readonly System.Linq.Expressions.StackGuard _guard
    [[deprecated("Use field access instead!")]] ::System::Linq::Expressions::StackGuard*& dyn__guard();
    // public System.Linq.Expressions.Interpreter.InstructionList get_Instructions()
    // Offset: 0xF21758
    ::System::Linq::Expressions::Interpreter::InstructionList* get_Instructions();
    // public System.Void .ctor()
    // Offset: 0xF2157C
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static LightCompiler* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("::System::Linq::Expressions::Interpreter::LightCompiler::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<LightCompiler*, creationType>()));
    }
    // private System.Void .ctor(System.Linq.Expressions.Interpreter.LightCompiler parent)
    // Offset: 0xF21730
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static LightCompiler* New_ctor(::System::Linq::Expressions::Interpreter::LightCompiler* parent) {
      static auto ___internal__logger = ::Logger::get().WithContext("::System::Linq::Expressions::Interpreter::LightCompiler::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<LightCompiler*, creationType>(parent)));
    }
    // static private System.Void .cctor()
    // Offset: 0xF2DA34
    static void _cctor();
    // public System.Linq.Expressions.Interpreter.LightDelegateCreator CompileTop(System.Linq.Expressions.LambdaExpression node)
    // Offset: 0xF21760
    ::System::Linq::Expressions::Interpreter::LightDelegateCreator* CompileTop(::System::Linq::Expressions::LambdaExpression* node);
    // private System.Linq.Expressions.Interpreter.Interpreter MakeInterpreter(System.String lambdaName)
    // Offset: 0xF219B8
    ::System::Linq::Expressions::Interpreter::Interpreter* MakeInterpreter(::StringW lambdaName);
    // private System.Void CompileConstantExpression(System.Linq.Expressions.Expression expr)
    // Offset: 0xF21CAC
    void CompileConstantExpression(::System::Linq::Expressions::Expression* expr);
    // private System.Void CompileDefaultExpression(System.Linq.Expressions.Expression expr)
    // Offset: 0xF21D60
    void CompileDefaultExpression(::System::Linq::Expressions::Expression* expr);
    // private System.Void CompileDefaultExpression(System.Type type)
    // Offset: 0xF21DA0
    void CompileDefaultExpression(::System::Type* type);
    // private System.Linq.Expressions.Interpreter.LocalVariable EnsureAvailableForClosure(System.Linq.Expressions.ParameterExpression expr)
    // Offset: 0xF21EB0
    ::System::Linq::Expressions::Interpreter::LocalVariable* EnsureAvailableForClosure(::System::Linq::Expressions::ParameterExpression* expr);
    // private System.Linq.Expressions.Interpreter.LocalVariable ResolveLocal(System.Linq.Expressions.ParameterExpression variable)
    // Offset: 0xF21FB8
    ::System::Linq::Expressions::Interpreter::LocalVariable* ResolveLocal(::System::Linq::Expressions::ParameterExpression* variable);
    // private System.Void CompileGetVariable(System.Linq.Expressions.ParameterExpression variable)
    // Offset: 0xF22018
    void CompileGetVariable(::System::Linq::Expressions::ParameterExpression* variable);
    // private System.Void EmitCopyValueType(System.Type valueType)
    // Offset: 0xF220DC
    void EmitCopyValueType(::System::Type* valueType);
    // private System.Void LoadLocalNoValueTypeCopy(System.Linq.Expressions.ParameterExpression variable)
    // Offset: 0xF2205C
    void LoadLocalNoValueTypeCopy(::System::Linq::Expressions::ParameterExpression* variable);
    // private System.Boolean MaybeMutableValueType(System.Type type)
    // Offset: 0xF2217C
    bool MaybeMutableValueType(::System::Type* type);
    // private System.Void CompileGetBoxedVariable(System.Linq.Expressions.ParameterExpression variable)
    // Offset: 0xF221E4
    void CompileGetBoxedVariable(::System::Linq::Expressions::ParameterExpression* variable);
    // private System.Void CompileSetVariable(System.Linq.Expressions.ParameterExpression variable, System.Boolean isVoid)
    // Offset: 0xF2223C
    void CompileSetVariable(::System::Linq::Expressions::ParameterExpression* variable, bool isVoid);
    // private System.Void CompileParameterExpression(System.Linq.Expressions.Expression expr)
    // Offset: 0xF22318
    void CompileParameterExpression(::System::Linq::Expressions::Expression* expr);
    // private System.Void CompileBlockExpression(System.Linq.Expressions.Expression expr, System.Boolean asVoid)
    // Offset: 0xF223A8
    void CompileBlockExpression(::System::Linq::Expressions::Expression* expr, bool asVoid);
    // private System.Linq.Expressions.Interpreter.LocalDefinition[] CompileBlockStart(System.Linq.Expressions.BlockExpression node)
    // Offset: 0xF224F4
    ::ArrayW<::System::Linq::Expressions::Interpreter::LocalDefinition> CompileBlockStart(::System::Linq::Expressions::BlockExpression* node);
    // private System.Void CompileBlockEnd(System.Linq.Expressions.Interpreter.LocalDefinition[] locals)
    // Offset: 0xF2295C
    void CompileBlockEnd(::ArrayW<::System::Linq::Expressions::Interpreter::LocalDefinition> locals);
    // private System.Void CompileIndexExpression(System.Linq.Expressions.Expression expr)
    // Offset: 0xF22BA0
    void CompileIndexExpression(::System::Linq::Expressions::Expression* expr);
    // private System.Void EmitIndexGet(System.Linq.Expressions.IndexExpression index)
    // Offset: 0xF22C70
    void EmitIndexGet(::System::Linq::Expressions::IndexExpression* index);
    // private System.Void CompileIndexAssignment(System.Linq.Expressions.BinaryExpression node, System.Boolean asVoid)
    // Offset: 0xF22D64
    void CompileIndexAssignment(::System::Linq::Expressions::BinaryExpression* node, bool asVoid);
    // private System.Void CompileMemberAssignment(System.Linq.Expressions.BinaryExpression node, System.Boolean asVoid)
    // Offset: 0xF2300C
    void CompileMemberAssignment(::System::Linq::Expressions::BinaryExpression* node, bool asVoid);
    // private System.Void CompileMemberAssignment(System.Boolean asVoid, System.Reflection.MemberInfo refMember, System.Linq.Expressions.Expression value, System.Boolean forBinding)
    // Offset: 0xF230D8
    void CompileMemberAssignment(bool asVoid, ::System::Reflection::MemberInfo* refMember, ::System::Linq::Expressions::Expression* value, bool forBinding);
    // private System.Void CompileVariableAssignment(System.Linq.Expressions.BinaryExpression node, System.Boolean asVoid)
    // Offset: 0xF23458
    void CompileVariableAssignment(::System::Linq::Expressions::BinaryExpression* node, bool asVoid);
    // private System.Void CompileAssignBinaryExpression(System.Linq.Expressions.Expression expr, System.Boolean asVoid)
    // Offset: 0xF23508
    void CompileAssignBinaryExpression(::System::Linq::Expressions::Expression* expr, bool asVoid);
    // private System.Void CompileBinaryExpression(System.Linq.Expressions.Expression expr)
    // Offset: 0xF23660
    void CompileBinaryExpression(::System::Linq::Expressions::Expression* expr);
    // private System.Void CompileEqual(System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Boolean liftedToNull)
    // Offset: 0xF245A0
    void CompileEqual(::System::Linq::Expressions::Expression* left, ::System::Linq::Expressions::Expression* right, bool liftedToNull);
    // private System.Void CompileNotEqual(System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right, System.Boolean liftedToNull)
    // Offset: 0xF24614
    void CompileNotEqual(::System::Linq::Expressions::Expression* left, ::System::Linq::Expressions::Expression* right, bool liftedToNull);
    // private System.Void CompileComparison(System.Linq.Expressions.BinaryExpression node)
    // Offset: 0xF24688
    void CompileComparison(::System::Linq::Expressions::BinaryExpression* node);
    // private System.Void CompileArithmetic(System.Linq.Expressions.ExpressionType nodeType, System.Linq.Expressions.Expression left, System.Linq.Expressions.Expression right)
    // Offset: 0xF24368
    void CompileArithmetic(::System::Linq::Expressions::ExpressionType nodeType, ::System::Linq::Expressions::Expression* left, ::System::Linq::Expressions::Expression* right);
    // private System.Void CompileConvertUnaryExpression(System.Linq.Expressions.Expression expr)
    // Offset: 0xF24818
    void CompileConvertUnaryExpression(::System::Linq::Expressions::Expression* expr);
    // private System.Void CompileConvertToType(System.Type typeFrom, System.Type typeTo, System.Boolean isChecked, System.Boolean isLiftedToNull)
    // Offset: 0xF24D74
    void CompileConvertToType(::System::Type* typeFrom, ::System::Type* typeTo, bool isChecked, bool isLiftedToNull);
    // private System.Void CompileNotExpression(System.Linq.Expressions.UnaryExpression node)
    // Offset: 0xF2525C
    void CompileNotExpression(::System::Linq::Expressions::UnaryExpression* node);
    // private System.Void CompileUnaryExpression(System.Linq.Expressions.Expression expr)
    // Offset: 0xF252B8
    void CompileUnaryExpression(::System::Linq::Expressions::Expression* expr);
    // private System.Void EmitUnaryMethodCall(System.Linq.Expressions.UnaryExpression node)
    // Offset: 0xF25594
    void EmitUnaryMethodCall(::System::Linq::Expressions::UnaryExpression* node);
    // private System.Void EmitUnaryBoolCheck(System.Linq.Expressions.UnaryExpression node)
    // Offset: 0xF256D0
    void EmitUnaryBoolCheck(::System::Linq::Expressions::UnaryExpression* node);
    // private System.Void CompileAndAlsoBinaryExpression(System.Linq.Expressions.Expression expr)
    // Offset: 0xF258C8
    void CompileAndAlsoBinaryExpression(::System::Linq::Expressions::Expression* expr);
    // private System.Void CompileOrElseBinaryExpression(System.Linq.Expressions.Expression expr)
    // Offset: 0xF25ADC
    void CompileOrElseBinaryExpression(::System::Linq::Expressions::Expression* expr);
    // private System.Void CompileLogicalBinaryExpression(System.Linq.Expressions.BinaryExpression b, System.Boolean andAlso)
    // Offset: 0xF2595C
    void CompileLogicalBinaryExpression(::System::Linq::Expressions::BinaryExpression* b, bool andAlso);
    // private System.Void CompileMethodLogicalBinaryExpression(System.Linq.Expressions.BinaryExpression expr, System.Boolean andAlso)
    // Offset: 0xF25B70
    void CompileMethodLogicalBinaryExpression(::System::Linq::Expressions::BinaryExpression* expr, bool andAlso);
    // private System.Void CompileLiftedLogicalBinaryExpression(System.Linq.Expressions.BinaryExpression node, System.Boolean andAlso)
    // Offset: 0xF25C9C
    void CompileLiftedLogicalBinaryExpression(::System::Linq::Expressions::BinaryExpression* node, bool andAlso);
    // private System.Void CompileUnliftedLogicalBinaryExpression(System.Linq.Expressions.BinaryExpression expr, System.Boolean andAlso)
    // Offset: 0xF26440
    void CompileUnliftedLogicalBinaryExpression(::System::Linq::Expressions::BinaryExpression* expr, bool andAlso);
    // private System.Void CompileConditionalExpression(System.Linq.Expressions.Expression expr, System.Boolean asVoid)
    // Offset: 0xF2652C
    void CompileConditionalExpression(::System::Linq::Expressions::Expression* expr, bool asVoid);
    // private System.Void CompileLoopExpression(System.Linq.Expressions.Expression expr)
    // Offset: 0xF26744
    void CompileLoopExpression(::System::Linq::Expressions::Expression* expr);
    // private System.Void CompileSwitchExpression(System.Linq.Expressions.Expression expr)
    // Offset: 0xF26A30
    void CompileSwitchExpression(::System::Linq::Expressions::Expression* expr);
    // private System.Void CompileIntSwitchExpression(System.Linq.Expressions.SwitchExpression node)
    // Offset: 0xFFFFFFFFFFFFFFFF
    template<class T>
    void CompileIntSwitchExpression(::System::Linq::Expressions::SwitchExpression* node) {
      static auto ___internal__logger = ::Logger::get().WithContext("::System::Linq::Expressions::Interpreter::LightCompiler::CompileIntSwitchExpression");
      static auto* ___internal__method = THROW_UNLESS((::il2cpp_utils::FindMethod(this, "CompileIntSwitchExpression", std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::std::vector<const Il2CppType*>{::il2cpp_utils::ExtractType(node)})));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{::il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      ::il2cpp_utils::RunMethodRethrow<void, false>(this, ___generic__method, node);
    }
    // private System.Void CompileStringSwitchExpression(System.Linq.Expressions.SwitchExpression node)
    // Offset: 0xF273C4
    void CompileStringSwitchExpression(::System::Linq::Expressions::SwitchExpression* node);
    // private System.Void CompileLabelExpression(System.Linq.Expressions.Expression expr)
    // Offset: 0xF27A4C
    void CompileLabelExpression(::System::Linq::Expressions::Expression* expr);
    // private System.Void CompileGotoExpression(System.Linq.Expressions.Expression expr)
    // Offset: 0xF27C00
    void CompileGotoExpression(::System::Linq::Expressions::Expression* expr);
    // private System.Void PushLabelBlock(System.Linq.Expressions.Interpreter.LabelScopeKind type)
    // Offset: 0xF2690C
    void PushLabelBlock(::System::Linq::Expressions::Interpreter::LabelScopeKind type);
    // private System.Void PopLabelBlock(System.Linq.Expressions.Interpreter.LabelScopeKind kind)
    // Offset: 0xF26A10
    void PopLabelBlock(::System::Linq::Expressions::Interpreter::LabelScopeKind kind);
    // private System.Linq.Expressions.Interpreter.LabelInfo EnsureLabel(System.Linq.Expressions.LabelTarget node)
    // Offset: 0xF27E2C
    ::System::Linq::Expressions::Interpreter::LabelInfo* EnsureLabel(::System::Linq::Expressions::LabelTarget* node);
    // private System.Linq.Expressions.Interpreter.LabelInfo ReferenceLabel(System.Linq.Expressions.LabelTarget node)
    // Offset: 0xF27DF4
    ::System::Linq::Expressions::Interpreter::LabelInfo* ReferenceLabel(::System::Linq::Expressions::LabelTarget* node);
    // private System.Linq.Expressions.Interpreter.LabelInfo DefineLabel(System.Linq.Expressions.LabelTarget node)
    // Offset: 0xF26980
    ::System::Linq::Expressions::Interpreter::LabelInfo* DefineLabel(::System::Linq::Expressions::LabelTarget* node);
    // private System.Boolean TryPushLabelBlock(System.Linq.Expressions.Expression node)
    // Offset: 0xF27F00
    bool TryPushLabelBlock(::System::Linq::Expressions::Expression* node);
    // private System.Void DefineBlockLabels(System.Linq.Expressions.Expression node)
    // Offset: 0xF28364
    void DefineBlockLabels(::System::Linq::Expressions::Expression* node);
    // private System.Void CheckRethrow()
    // Offset: 0xF284A4
    void CheckRethrow();
    // private System.Void CompileThrowUnaryExpression(System.Linq.Expressions.Expression expr, System.Boolean asVoid)
    // Offset: 0xF284FC
    void CompileThrowUnaryExpression(::System::Linq::Expressions::Expression* expr, bool asVoid);
    // private System.Void CompileTryExpression(System.Linq.Expressions.Expression expr)
    // Offset: 0xF28600
    void CompileTryExpression(::System::Linq::Expressions::Expression* expr);
    // private System.Void CompileTryFaultExpression(System.Linq.Expressions.TryExpression expr)
    // Offset: 0xF29068
    void CompileTryFaultExpression(::System::Linq::Expressions::TryExpression* expr);
    // private System.Void CompileMethodCallExpression(System.Linq.Expressions.Expression expr)
    // Offset: 0xF292A8
    void CompileMethodCallExpression(::System::Linq::Expressions::Expression* expr);
    // private System.Void CompileMethodCallExpression(System.Linq.Expressions.Expression object, System.Reflection.MethodInfo method, System.Linq.Expressions.IArgumentProvider arguments)
    // Offset: 0xF29350
    void CompileMethodCallExpression(::System::Linq::Expressions::Expression* object, ::System::Reflection::MethodInfo* method, ::System::Linq::Expressions::IArgumentProvider* arguments);
    // private System.Linq.Expressions.Interpreter.ByRefUpdater CompileArrayIndexAddress(System.Linq.Expressions.Expression array, System.Linq.Expressions.Expression index, System.Int32 argumentIndex)
    // Offset: 0xF2A128
    ::System::Linq::Expressions::Interpreter::ByRefUpdater* CompileArrayIndexAddress(::System::Linq::Expressions::Expression* array, ::System::Linq::Expressions::Expression* index, int argumentIndex);
    // private System.Void EmitThisForMethodCall(System.Linq.Expressions.Expression node)
    // Offset: 0xF22C68
    void EmitThisForMethodCall(::System::Linq::Expressions::Expression* node);
    // static private System.Boolean ShouldWritebackNode(System.Linq.Expressions.Expression node)
    // Offset: 0xF2A334
    static bool ShouldWritebackNode(::System::Linq::Expressions::Expression* node);
    // private System.Linq.Expressions.Interpreter.ByRefUpdater CompileAddress(System.Linq.Expressions.Expression node, System.Int32 index)
    // Offset: 0xF297D0
    ::System::Linq::Expressions::Interpreter::ByRefUpdater* CompileAddress(::System::Linq::Expressions::Expression* node, int index);
    // private System.Linq.Expressions.Interpreter.ByRefUpdater CompileMultiDimArrayAccess(System.Linq.Expressions.Expression array, System.Linq.Expressions.IArgumentProvider arguments, System.Int32 index)
    // Offset: 0xF2A4BC
    ::System::Linq::Expressions::Interpreter::ByRefUpdater* CompileMultiDimArrayAccess(::System::Linq::Expressions::Expression* array, ::System::Linq::Expressions::IArgumentProvider* arguments, int index);
    // private System.Void CompileNewExpression(System.Linq.Expressions.Expression expr)
    // Offset: 0xF2A8E4
    void CompileNewExpression(::System::Linq::Expressions::Expression* expr);
    // private System.Void CompileMemberExpression(System.Linq.Expressions.Expression expr)
    // Offset: 0xF2AC48
    void CompileMemberExpression(::System::Linq::Expressions::Expression* expr);
    // private System.Void CompileMember(System.Linq.Expressions.Expression from, System.Reflection.MemberInfo member, System.Boolean forBinding)
    // Offset: 0xF2ACF4
    void CompileMember(::System::Linq::Expressions::Expression* from, ::System::Reflection::MemberInfo* member, bool forBinding);
    // private System.Void CompileNewArrayExpression(System.Linq.Expressions.Expression expr)
    // Offset: 0xF2B064
    void CompileNewArrayExpression(::System::Linq::Expressions::Expression* expr);
    // private System.Void CompileDebugInfoExpression(System.Linq.Expressions.Expression expr)
    // Offset: 0xF2B3BC
    void CompileDebugInfoExpression(::System::Linq::Expressions::Expression* expr);
    // private System.Void CompileRuntimeVariablesExpression(System.Linq.Expressions.Expression expr)
    // Offset: 0xF2B504
    void CompileRuntimeVariablesExpression(::System::Linq::Expressions::Expression* expr);
    // private System.Void CompileLambdaExpression(System.Linq.Expressions.Expression expr)
    // Offset: 0xF2B7E8
    void CompileLambdaExpression(::System::Linq::Expressions::Expression* expr);
    // private System.Void CompileCoalesceBinaryExpression(System.Linq.Expressions.Expression expr)
    // Offset: 0xF2B9D4
    void CompileCoalesceBinaryExpression(::System::Linq::Expressions::Expression* expr);
    // private System.Void CompileInvocationExpression(System.Linq.Expressions.Expression expr)
    // Offset: 0xF2BDC8
    void CompileInvocationExpression(::System::Linq::Expressions::Expression* expr);
    // private System.Void CompileListInitExpression(System.Linq.Expressions.Expression expr)
    // Offset: 0xF2C06C
    void CompileListInitExpression(::System::Linq::Expressions::Expression* expr);
    // private System.Void CompileListInit(System.Collections.ObjectModel.ReadOnlyCollection`1<System.Linq.Expressions.ElementInit> initializers)
    // Offset: 0xF2C0F4
    void CompileListInit(::System::Collections::ObjectModel::ReadOnlyCollection_1<::System::Linq::Expressions::ElementInit*>* initializers);
    // private System.Void CompileMemberInitExpression(System.Linq.Expressions.Expression expr)
    // Offset: 0xF2C4AC
    void CompileMemberInitExpression(::System::Linq::Expressions::Expression* expr);
    // private System.Void CompileMemberInit(System.Collections.ObjectModel.ReadOnlyCollection`1<System.Linq.Expressions.MemberBinding> bindings)
    // Offset: 0xF2C534
    void CompileMemberInit(::System::Collections::ObjectModel::ReadOnlyCollection_1<::System::Linq::Expressions::MemberBinding*>* bindings);
    // static private System.Type GetMemberType(System.Reflection.MemberInfo member)
    // Offset: 0xF2CA14
    static ::System::Type* GetMemberType(::System::Reflection::MemberInfo* member);
    // private System.Void CompileQuoteUnaryExpression(System.Linq.Expressions.Expression expr)
    // Offset: 0xF2CB7C
    void CompileQuoteUnaryExpression(::System::Linq::Expressions::Expression* expr);
    // private System.Void CompileUnboxUnaryExpression(System.Linq.Expressions.Expression expr)
    // Offset: 0xF2CE0C
    void CompileUnboxUnaryExpression(::System::Linq::Expressions::Expression* expr);
    // private System.Void CompileTypeEqualExpression(System.Linq.Expressions.Expression expr)
    // Offset: 0xF2CF18
    void CompileTypeEqualExpression(::System::Linq::Expressions::Expression* expr);
    // private System.Void CompileTypeAsExpression(System.Linq.Expressions.UnaryExpression node)
    // Offset: 0xF25680
    void CompileTypeAsExpression(::System::Linq::Expressions::UnaryExpression* node);
    // private System.Void CompileTypeIsExpression(System.Linq.Expressions.Expression expr)
    // Offset: 0xF2D10C
    void CompileTypeIsExpression(::System::Linq::Expressions::Expression* expr);
    // private System.Void Compile(System.Linq.Expressions.Expression expr, System.Boolean asVoid)
    // Offset: 0xF22950
    void Compile(::System::Linq::Expressions::Expression* expr, bool asVoid);
    // private System.Void CompileAsVoid(System.Linq.Expressions.Expression expr)
    // Offset: 0xF22A0C
    void CompileAsVoid(::System::Linq::Expressions::Expression* expr);
    // private System.Void CompileNoLabelPush(System.Linq.Expressions.Expression expr)
    // Offset: 0xF2D340
    void CompileNoLabelPush(::System::Linq::Expressions::Expression* expr);
    // private System.Void Compile(System.Linq.Expressions.Expression expr)
    // Offset: 0xF21964
    void Compile(::System::Linq::Expressions::Expression* expr);
  }; // System.Linq.Expressions.Interpreter.LightCompiler
  #pragma pack(pop)
  static check_size<sizeof(LightCompiler), 72 + sizeof(::System::Linq::Expressions::StackGuard*)> __System_Linq_Expressions_Interpreter_LightCompilerSizeCheck;
  static_assert(sizeof(LightCompiler) == 0x50);
}
#include "beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::get_Instructions
// Il2CppName: get_Instructions
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Linq::Expressions::Interpreter::InstructionList* (System::Linq::Expressions::Interpreter::LightCompiler::*)()>(&System::Linq::Expressions::Interpreter::LightCompiler::get_Instructions)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "get_Instructions", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::New_ctor
// Il2CppName: .ctor
// Cannot get method pointer of value based method overload from template for constructor!
// Try using FindMethod instead!
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::_cctor
// Il2CppName: .cctor
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (*)()>(&System::Linq::Expressions::Interpreter::LightCompiler::_cctor)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), ".cctor", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileTop
// Il2CppName: CompileTop
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Linq::Expressions::Interpreter::LightDelegateCreator* (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::LambdaExpression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileTop)> {
  static const MethodInfo* get() {
    static auto* node = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "LambdaExpression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileTop", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{node});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::MakeInterpreter
// Il2CppName: MakeInterpreter
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Linq::Expressions::Interpreter::Interpreter* (System::Linq::Expressions::Interpreter::LightCompiler::*)(::StringW)>(&System::Linq::Expressions::Interpreter::LightCompiler::MakeInterpreter)> {
  static const MethodInfo* get() {
    static auto* lambdaName = &::il2cpp_utils::GetClassFromName("System", "String")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "MakeInterpreter", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{lambdaName});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileConstantExpression
// Il2CppName: CompileConstantExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileConstantExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileConstantExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileDefaultExpression
// Il2CppName: CompileDefaultExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileDefaultExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileDefaultExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileDefaultExpression
// Il2CppName: CompileDefaultExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Type*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileDefaultExpression)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileDefaultExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::EnsureAvailableForClosure
// Il2CppName: EnsureAvailableForClosure
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Linq::Expressions::Interpreter::LocalVariable* (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::ParameterExpression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::EnsureAvailableForClosure)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "ParameterExpression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "EnsureAvailableForClosure", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::ResolveLocal
// Il2CppName: ResolveLocal
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Linq::Expressions::Interpreter::LocalVariable* (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::ParameterExpression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::ResolveLocal)> {
  static const MethodInfo* get() {
    static auto* variable = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "ParameterExpression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "ResolveLocal", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{variable});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileGetVariable
// Il2CppName: CompileGetVariable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::ParameterExpression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileGetVariable)> {
  static const MethodInfo* get() {
    static auto* variable = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "ParameterExpression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileGetVariable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{variable});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::EmitCopyValueType
// Il2CppName: EmitCopyValueType
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Type*)>(&System::Linq::Expressions::Interpreter::LightCompiler::EmitCopyValueType)> {
  static const MethodInfo* get() {
    static auto* valueType = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "EmitCopyValueType", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{valueType});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::LoadLocalNoValueTypeCopy
// Il2CppName: LoadLocalNoValueTypeCopy
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::ParameterExpression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::LoadLocalNoValueTypeCopy)> {
  static const MethodInfo* get() {
    static auto* variable = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "ParameterExpression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "LoadLocalNoValueTypeCopy", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{variable});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::MaybeMutableValueType
// Il2CppName: MaybeMutableValueType
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Type*)>(&System::Linq::Expressions::Interpreter::LightCompiler::MaybeMutableValueType)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "MaybeMutableValueType", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileGetBoxedVariable
// Il2CppName: CompileGetBoxedVariable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::ParameterExpression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileGetBoxedVariable)> {
  static const MethodInfo* get() {
    static auto* variable = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "ParameterExpression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileGetBoxedVariable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{variable});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileSetVariable
// Il2CppName: CompileSetVariable
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::ParameterExpression*, bool)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileSetVariable)> {
  static const MethodInfo* get() {
    static auto* variable = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "ParameterExpression")->byval_arg;
    static auto* isVoid = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileSetVariable", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{variable, isVoid});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileParameterExpression
// Il2CppName: CompileParameterExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileParameterExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileParameterExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileBlockExpression
// Il2CppName: CompileBlockExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*, bool)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileBlockExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    static auto* asVoid = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileBlockExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr, asVoid});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileBlockStart
// Il2CppName: CompileBlockStart
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::ArrayW<::System::Linq::Expressions::Interpreter::LocalDefinition> (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::BlockExpression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileBlockStart)> {
  static const MethodInfo* get() {
    static auto* node = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "BlockExpression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileBlockStart", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{node});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileBlockEnd
// Il2CppName: CompileBlockEnd
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::ArrayW<::System::Linq::Expressions::Interpreter::LocalDefinition>)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileBlockEnd)> {
  static const MethodInfo* get() {
    static auto* locals = &il2cpp_functions::array_class_get(::il2cpp_utils::GetClassFromName("System.Linq.Expressions.Interpreter", "LocalDefinition"), 1)->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileBlockEnd", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{locals});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileIndexExpression
// Il2CppName: CompileIndexExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileIndexExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileIndexExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::EmitIndexGet
// Il2CppName: EmitIndexGet
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::IndexExpression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::EmitIndexGet)> {
  static const MethodInfo* get() {
    static auto* index = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "IndexExpression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "EmitIndexGet", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{index});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileIndexAssignment
// Il2CppName: CompileIndexAssignment
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::BinaryExpression*, bool)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileIndexAssignment)> {
  static const MethodInfo* get() {
    static auto* node = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "BinaryExpression")->byval_arg;
    static auto* asVoid = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileIndexAssignment", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{node, asVoid});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileMemberAssignment
// Il2CppName: CompileMemberAssignment
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::BinaryExpression*, bool)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileMemberAssignment)> {
  static const MethodInfo* get() {
    static auto* node = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "BinaryExpression")->byval_arg;
    static auto* asVoid = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileMemberAssignment", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{node, asVoid});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileMemberAssignment
// Il2CppName: CompileMemberAssignment
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(bool, ::System::Reflection::MemberInfo*, ::System::Linq::Expressions::Expression*, bool)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileMemberAssignment)> {
  static const MethodInfo* get() {
    static auto* asVoid = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* refMember = &::il2cpp_utils::GetClassFromName("System.Reflection", "MemberInfo")->byval_arg;
    static auto* value = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    static auto* forBinding = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileMemberAssignment", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{asVoid, refMember, value, forBinding});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileVariableAssignment
// Il2CppName: CompileVariableAssignment
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::BinaryExpression*, bool)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileVariableAssignment)> {
  static const MethodInfo* get() {
    static auto* node = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "BinaryExpression")->byval_arg;
    static auto* asVoid = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileVariableAssignment", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{node, asVoid});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileAssignBinaryExpression
// Il2CppName: CompileAssignBinaryExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*, bool)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileAssignBinaryExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    static auto* asVoid = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileAssignBinaryExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr, asVoid});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileBinaryExpression
// Il2CppName: CompileBinaryExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileBinaryExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileBinaryExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileEqual
// Il2CppName: CompileEqual
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*, ::System::Linq::Expressions::Expression*, bool)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileEqual)> {
  static const MethodInfo* get() {
    static auto* left = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    static auto* right = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    static auto* liftedToNull = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileEqual", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{left, right, liftedToNull});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileNotEqual
// Il2CppName: CompileNotEqual
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*, ::System::Linq::Expressions::Expression*, bool)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileNotEqual)> {
  static const MethodInfo* get() {
    static auto* left = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    static auto* right = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    static auto* liftedToNull = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileNotEqual", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{left, right, liftedToNull});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileComparison
// Il2CppName: CompileComparison
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::BinaryExpression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileComparison)> {
  static const MethodInfo* get() {
    static auto* node = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "BinaryExpression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileComparison", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{node});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileArithmetic
// Il2CppName: CompileArithmetic
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::ExpressionType, ::System::Linq::Expressions::Expression*, ::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileArithmetic)> {
  static const MethodInfo* get() {
    static auto* nodeType = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "ExpressionType")->byval_arg;
    static auto* left = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    static auto* right = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileArithmetic", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{nodeType, left, right});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileConvertUnaryExpression
// Il2CppName: CompileConvertUnaryExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileConvertUnaryExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileConvertUnaryExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileConvertToType
// Il2CppName: CompileConvertToType
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Type*, ::System::Type*, bool, bool)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileConvertToType)> {
  static const MethodInfo* get() {
    static auto* typeFrom = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* typeTo = &::il2cpp_utils::GetClassFromName("System", "Type")->byval_arg;
    static auto* isChecked = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    static auto* isLiftedToNull = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileConvertToType", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{typeFrom, typeTo, isChecked, isLiftedToNull});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileNotExpression
// Il2CppName: CompileNotExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::UnaryExpression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileNotExpression)> {
  static const MethodInfo* get() {
    static auto* node = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "UnaryExpression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileNotExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{node});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileUnaryExpression
// Il2CppName: CompileUnaryExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileUnaryExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileUnaryExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::EmitUnaryMethodCall
// Il2CppName: EmitUnaryMethodCall
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::UnaryExpression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::EmitUnaryMethodCall)> {
  static const MethodInfo* get() {
    static auto* node = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "UnaryExpression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "EmitUnaryMethodCall", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{node});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::EmitUnaryBoolCheck
// Il2CppName: EmitUnaryBoolCheck
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::UnaryExpression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::EmitUnaryBoolCheck)> {
  static const MethodInfo* get() {
    static auto* node = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "UnaryExpression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "EmitUnaryBoolCheck", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{node});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileAndAlsoBinaryExpression
// Il2CppName: CompileAndAlsoBinaryExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileAndAlsoBinaryExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileAndAlsoBinaryExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileOrElseBinaryExpression
// Il2CppName: CompileOrElseBinaryExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileOrElseBinaryExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileOrElseBinaryExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileLogicalBinaryExpression
// Il2CppName: CompileLogicalBinaryExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::BinaryExpression*, bool)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileLogicalBinaryExpression)> {
  static const MethodInfo* get() {
    static auto* b = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "BinaryExpression")->byval_arg;
    static auto* andAlso = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileLogicalBinaryExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{b, andAlso});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileMethodLogicalBinaryExpression
// Il2CppName: CompileMethodLogicalBinaryExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::BinaryExpression*, bool)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileMethodLogicalBinaryExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "BinaryExpression")->byval_arg;
    static auto* andAlso = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileMethodLogicalBinaryExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr, andAlso});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileLiftedLogicalBinaryExpression
// Il2CppName: CompileLiftedLogicalBinaryExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::BinaryExpression*, bool)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileLiftedLogicalBinaryExpression)> {
  static const MethodInfo* get() {
    static auto* node = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "BinaryExpression")->byval_arg;
    static auto* andAlso = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileLiftedLogicalBinaryExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{node, andAlso});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileUnliftedLogicalBinaryExpression
// Il2CppName: CompileUnliftedLogicalBinaryExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::BinaryExpression*, bool)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileUnliftedLogicalBinaryExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "BinaryExpression")->byval_arg;
    static auto* andAlso = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileUnliftedLogicalBinaryExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr, andAlso});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileConditionalExpression
// Il2CppName: CompileConditionalExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*, bool)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileConditionalExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    static auto* asVoid = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileConditionalExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr, asVoid});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileLoopExpression
// Il2CppName: CompileLoopExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileLoopExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileLoopExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileSwitchExpression
// Il2CppName: CompileSwitchExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileSwitchExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileSwitchExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileIntSwitchExpression
// Il2CppName: CompileIntSwitchExpression
// Cannot write MetadataGetter for generic methods!
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileStringSwitchExpression
// Il2CppName: CompileStringSwitchExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::SwitchExpression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileStringSwitchExpression)> {
  static const MethodInfo* get() {
    static auto* node = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "SwitchExpression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileStringSwitchExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{node});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileLabelExpression
// Il2CppName: CompileLabelExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileLabelExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileLabelExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileGotoExpression
// Il2CppName: CompileGotoExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileGotoExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileGotoExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::PushLabelBlock
// Il2CppName: PushLabelBlock
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Interpreter::LabelScopeKind)>(&System::Linq::Expressions::Interpreter::LightCompiler::PushLabelBlock)> {
  static const MethodInfo* get() {
    static auto* type = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions.Interpreter", "LabelScopeKind")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "PushLabelBlock", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{type});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::PopLabelBlock
// Il2CppName: PopLabelBlock
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Interpreter::LabelScopeKind)>(&System::Linq::Expressions::Interpreter::LightCompiler::PopLabelBlock)> {
  static const MethodInfo* get() {
    static auto* kind = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions.Interpreter", "LabelScopeKind")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "PopLabelBlock", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{kind});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::EnsureLabel
// Il2CppName: EnsureLabel
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Linq::Expressions::Interpreter::LabelInfo* (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::LabelTarget*)>(&System::Linq::Expressions::Interpreter::LightCompiler::EnsureLabel)> {
  static const MethodInfo* get() {
    static auto* node = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "LabelTarget")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "EnsureLabel", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{node});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::ReferenceLabel
// Il2CppName: ReferenceLabel
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Linq::Expressions::Interpreter::LabelInfo* (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::LabelTarget*)>(&System::Linq::Expressions::Interpreter::LightCompiler::ReferenceLabel)> {
  static const MethodInfo* get() {
    static auto* node = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "LabelTarget")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "ReferenceLabel", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{node});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::DefineLabel
// Il2CppName: DefineLabel
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Linq::Expressions::Interpreter::LabelInfo* (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::LabelTarget*)>(&System::Linq::Expressions::Interpreter::LightCompiler::DefineLabel)> {
  static const MethodInfo* get() {
    static auto* node = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "LabelTarget")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "DefineLabel", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{node});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::TryPushLabelBlock
// Il2CppName: TryPushLabelBlock
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::TryPushLabelBlock)> {
  static const MethodInfo* get() {
    static auto* node = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "TryPushLabelBlock", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{node});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::DefineBlockLabels
// Il2CppName: DefineBlockLabels
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::DefineBlockLabels)> {
  static const MethodInfo* get() {
    static auto* node = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "DefineBlockLabels", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{node});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CheckRethrow
// Il2CppName: CheckRethrow
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)()>(&System::Linq::Expressions::Interpreter::LightCompiler::CheckRethrow)> {
  static const MethodInfo* get() {
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CheckRethrow", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileThrowUnaryExpression
// Il2CppName: CompileThrowUnaryExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*, bool)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileThrowUnaryExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    static auto* asVoid = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileThrowUnaryExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr, asVoid});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileTryExpression
// Il2CppName: CompileTryExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileTryExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileTryExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileTryFaultExpression
// Il2CppName: CompileTryFaultExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::TryExpression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileTryFaultExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "TryExpression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileTryFaultExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileMethodCallExpression
// Il2CppName: CompileMethodCallExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileMethodCallExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileMethodCallExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileMethodCallExpression
// Il2CppName: CompileMethodCallExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*, ::System::Reflection::MethodInfo*, ::System::Linq::Expressions::IArgumentProvider*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileMethodCallExpression)> {
  static const MethodInfo* get() {
    static auto* object = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    static auto* method = &::il2cpp_utils::GetClassFromName("System.Reflection", "MethodInfo")->byval_arg;
    static auto* arguments = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "IArgumentProvider")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileMethodCallExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{object, method, arguments});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileArrayIndexAddress
// Il2CppName: CompileArrayIndexAddress
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Linq::Expressions::Interpreter::ByRefUpdater* (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*, ::System::Linq::Expressions::Expression*, int)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileArrayIndexAddress)> {
  static const MethodInfo* get() {
    static auto* array = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    static auto* index = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    static auto* argumentIndex = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileArrayIndexAddress", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{array, index, argumentIndex});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::EmitThisForMethodCall
// Il2CppName: EmitThisForMethodCall
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::EmitThisForMethodCall)> {
  static const MethodInfo* get() {
    static auto* node = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "EmitThisForMethodCall", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{node});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::ShouldWritebackNode
// Il2CppName: ShouldWritebackNode
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<bool (*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::ShouldWritebackNode)> {
  static const MethodInfo* get() {
    static auto* node = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "ShouldWritebackNode", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{node});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileAddress
// Il2CppName: CompileAddress
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Linq::Expressions::Interpreter::ByRefUpdater* (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*, int)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileAddress)> {
  static const MethodInfo* get() {
    static auto* node = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    static auto* index = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileAddress", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{node, index});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileMultiDimArrayAccess
// Il2CppName: CompileMultiDimArrayAccess
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Linq::Expressions::Interpreter::ByRefUpdater* (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*, ::System::Linq::Expressions::IArgumentProvider*, int)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileMultiDimArrayAccess)> {
  static const MethodInfo* get() {
    static auto* array = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    static auto* arguments = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "IArgumentProvider")->byval_arg;
    static auto* index = &::il2cpp_utils::GetClassFromName("System", "Int32")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileMultiDimArrayAccess", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{array, arguments, index});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileNewExpression
// Il2CppName: CompileNewExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileNewExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileNewExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileMemberExpression
// Il2CppName: CompileMemberExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileMemberExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileMemberExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileMember
// Il2CppName: CompileMember
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*, ::System::Reflection::MemberInfo*, bool)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileMember)> {
  static const MethodInfo* get() {
    static auto* from = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    static auto* member = &::il2cpp_utils::GetClassFromName("System.Reflection", "MemberInfo")->byval_arg;
    static auto* forBinding = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileMember", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{from, member, forBinding});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileNewArrayExpression
// Il2CppName: CompileNewArrayExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileNewArrayExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileNewArrayExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileDebugInfoExpression
// Il2CppName: CompileDebugInfoExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileDebugInfoExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileDebugInfoExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileRuntimeVariablesExpression
// Il2CppName: CompileRuntimeVariablesExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileRuntimeVariablesExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileRuntimeVariablesExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileLambdaExpression
// Il2CppName: CompileLambdaExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileLambdaExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileLambdaExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileCoalesceBinaryExpression
// Il2CppName: CompileCoalesceBinaryExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileCoalesceBinaryExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileCoalesceBinaryExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileInvocationExpression
// Il2CppName: CompileInvocationExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileInvocationExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileInvocationExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileListInitExpression
// Il2CppName: CompileListInitExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileListInitExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileListInitExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileListInit
// Il2CppName: CompileListInit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Collections::ObjectModel::ReadOnlyCollection_1<::System::Linq::Expressions::ElementInit*>*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileListInit)> {
  static const MethodInfo* get() {
    static auto* initializers = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.ObjectModel", "ReadOnlyCollection`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "ElementInit")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileListInit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{initializers});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileMemberInitExpression
// Il2CppName: CompileMemberInitExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileMemberInitExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileMemberInitExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileMemberInit
// Il2CppName: CompileMemberInit
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Collections::ObjectModel::ReadOnlyCollection_1<::System::Linq::Expressions::MemberBinding*>*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileMemberInit)> {
  static const MethodInfo* get() {
    static auto* bindings = &::il2cpp_utils::MakeGeneric(::il2cpp_utils::GetClassFromName("System.Collections.ObjectModel", "ReadOnlyCollection`1"), ::std::vector<const Il2CppClass*>{::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "MemberBinding")})->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileMemberInit", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{bindings});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::GetMemberType
// Il2CppName: GetMemberType
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<::System::Type* (*)(::System::Reflection::MemberInfo*)>(&System::Linq::Expressions::Interpreter::LightCompiler::GetMemberType)> {
  static const MethodInfo* get() {
    static auto* member = &::il2cpp_utils::GetClassFromName("System.Reflection", "MemberInfo")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "GetMemberType", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{member});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileQuoteUnaryExpression
// Il2CppName: CompileQuoteUnaryExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileQuoteUnaryExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileQuoteUnaryExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileUnboxUnaryExpression
// Il2CppName: CompileUnboxUnaryExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileUnboxUnaryExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileUnboxUnaryExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileTypeEqualExpression
// Il2CppName: CompileTypeEqualExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileTypeEqualExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileTypeEqualExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileTypeAsExpression
// Il2CppName: CompileTypeAsExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::UnaryExpression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileTypeAsExpression)> {
  static const MethodInfo* get() {
    static auto* node = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "UnaryExpression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileTypeAsExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{node});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileTypeIsExpression
// Il2CppName: CompileTypeIsExpression
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileTypeIsExpression)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileTypeIsExpression", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::Compile
// Il2CppName: Compile
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*, bool)>(&System::Linq::Expressions::Interpreter::LightCompiler::Compile)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    static auto* asVoid = &::il2cpp_utils::GetClassFromName("System", "Boolean")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "Compile", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr, asVoid});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileAsVoid
// Il2CppName: CompileAsVoid
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileAsVoid)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileAsVoid", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::CompileNoLabelPush
// Il2CppName: CompileNoLabelPush
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::CompileNoLabelPush)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "CompileNoLabelPush", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
// Writing MetadataGetter for method: System::Linq::Expressions::Interpreter::LightCompiler::Compile
// Il2CppName: Compile
template<>
struct ::il2cpp_utils::il2cpp_type_check::MetadataGetter<static_cast<void (System::Linq::Expressions::Interpreter::LightCompiler::*)(::System::Linq::Expressions::Expression*)>(&System::Linq::Expressions::Interpreter::LightCompiler::Compile)> {
  static const MethodInfo* get() {
    static auto* expr = &::il2cpp_utils::GetClassFromName("System.Linq.Expressions", "Expression")->byval_arg;
    return ::il2cpp_utils::FindMethod(classof(System::Linq::Expressions::Interpreter::LightCompiler*), "Compile", std::vector<Il2CppClass*>(), ::std::vector<const Il2CppType*>{expr});
  }
};
